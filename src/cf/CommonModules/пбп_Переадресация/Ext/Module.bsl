///////////////////////////////////////////////////////////////////////////////////////////////////////
// Библиотека проектных подсистем для упрощения разработки архитектуры на 1С: Предприятие 8,
// включая доработку типовых конфигураций.
//
// Copyright First BIT company
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
// URL: https://github.com/firstBitSportivnaya/PSSL/
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция ОпределитьМодульПереадресации предназначена для проверки наличия общего модуля
// БСП с указанным именем и получения этого модуля, если он существует.
//
// Параметры:
//  ИмяМодуля	 - Строка - имя общего модуля, который необходимо найти.
// 
// Возвращаемое значение:
//  Структура - общий модуль и что он существует
//  * Модуль 	- ОбщийМодуль - общий модуль из БСП.
//  * МодульСуществует - Булево - Если флаг истина, модуль существует.
//
Функция ОпределитьМодульПереадресации(ИмяМодуля) Экспорт
	
	Результат = Новый Структура("Модуль, МодульСуществует", , Ложь);
	
	Если пбп_ОбщегоНазначенияПовтИсп.СуществуетБиблиотекаСтандартныхПодсистем()
		И Метаданные.ОбщиеМодули.Найти(ИмяМодуля) <> Неопределено Тогда
		Результат.Модуль = ОбщийМодуль(ИмяМодуля);
		Результат.МодульСуществует = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Область ПереадресацияМетодов

#Область ЖурналРегистрации

// Аналог метода БСП. Записывает сообщение в журнал регистрации.
//
//  Параметры: 
//   ИмяСобытия       - Строка - имя события для журнала регистрации.
//   Уровень          - УровеньЖурналаРегистрации - уровни важности событий журнала регистрации.
//   ОбъектМетаданных - ОбъектМетаданных - объект метаданных, к которому относится событие.
//   Данные           - ЛюбаяСсылка
//                    - Число
//                    - Строка
//                    - Дата
//                    - Булево
//                    - Неопределено
//                    - Тип - данные, с которыми связано событие.
//                      Рекомендуется указывать ссылки на объекты данных (элементы справочников, документы, к которым
//                      относится событие).
//   Комментарий      - Строка - комментарий для события журнала.
//
Процедура ДобавитьСообщениеДляЖурналаРегистрации(Знач ИмяСобытия, Знач Уровень,
		Знач ОбъектМетаданных = Неопределено, Знач Данные = Неопределено, Знач Комментарий = "") Экспорт
	
	Результат = ПереадресацияМодуляЖурналРегистрации();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ДобавитьСообщениеДляЖурналаРегистрации(ИмяСобытия, Уровень, ОбъектМетаданных, Данные, Комментарий);
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяСобытия) Тогда
		ИмяСобытия = "Событие"; // не локализуется, чтобы не допускать остановки запуска в частично переведенной конфигурации
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, Уровень,
		ОбъектМетаданных, Данные, Комментарий, РежимТранзакцииЗаписиЖурналаРегистрации.Независимая);
	
КонецПроцедуры

#КонецОбласти

#Область ОбщегоНазначения

// Аналог метода БСП. Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево - Истина, если файловая.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы);
	КонецЕсли;
	
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции

// Аналог метода БСП. Возвращает Истина, если функциональная подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
// У функциональной подсистемы снят флажок "Включать в командный интерфейс".
// См. также ОбщегоНазначенияПереопределяемый.ПриОпределенииОтключенныхПодсистем
// и ОбщегоНазначенияКлиент.ПодсистемаСуществует для вызова из клиентского кода.
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево - Истина, если подсистема существует.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ПодсистемаСуществует(ПолноеИмяПодсистемы);
	КонецЕсли;
	
	ИменаПодсистем = пбп_ПереадресацияПовтИсп.ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Аналог метода БСП. Возвращает ссылку на общий модуль или модуль менеджера по имени.
//
// Параметры:
//  Имя - Строка - имя общего модуля.
//
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
//
// Пример:
//	МодульОбновлениеКонфигурации = пбп_ОбщегоНазначенияСервер.ОбщийМодуль("ОбновлениеКонфигурации");
//	МодульОбновлениеКонфигурации.<Имя метода>();
//
//	МодульПолнотекстовыйПоискСервер = пбп_ОбщегоНазначенияСервер.ОбщийМодуль("ПолнотекстовыйПоискСервер");
//	МодульПолнотекстовыйПоискСервер.<Имя метода>();
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ОбщийМодуль(Имя);
	КонецЕсли;
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		// BSLLS:ExecuteExternalCodeInCommonModule-off
		// ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
		УстановитьБезопасныйРежим(Истина);
		Модуль = Вычислить(Имя);
		// BSLLS:ExecuteExternalCodeInCommonModule-on
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Общий модуль ""%1"" не существует.'"),
			Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

// Аналог метода БСП. Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемым для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной процедуры в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                        в порядке расположения элементов массива.
// 
// Пример:
//  Параметры = Новый Массив();
//  Параметры.Добавить("1");
//  ОбщегоНазначения.ВыполнитьМетодКонфигурации("МойОбщийМодуль.МояПроцедура", Параметры);
//
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ВыполнитьМетодКонфигурации(ИмяМетода, Параметры);
		Возврат;
	КонецЕсли;
	
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	УстановитьБезопасныйРежим(Истина);
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + XMLСтрока(Индекс) + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Аналог метода БСП. Вызвать экспортную функцию по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной функции в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в функцию <ИмяМетода>
//                        в порядке расположения элементов массива.
//
// Возвращаемое значение:
//  Произвольный - результат вызываемой функции.
//
Функция ВызватьФункциюКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ВызватьФункциюКонфигурации(ИмяМетода, Параметры);
	КонецЕсли;
	
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПрофилиБезопасности") Тогда
		МодульРаботаВБезопасномРежиме = ОбщийМодуль("РаботаВБезопасномРежиме");
		Если МодульРаботаВБезопасномРежиме.ИспользуютсяПрофилиБезопасности()
			И Не МодульРаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
			
			ПрофильИнформационнойБазы = МодульРаботаВБезопасномРежиме.ПрофильБезопасностиИнформационнойБазы();
			Если ЗначениеЗаполнено(ПрофильИнформационнойБазы) Тогда
				
				// BSLLS:DisableSafeMode-off
				УстановитьБезопасныйРежим(ПрофильИнформационнойБазы);
				// BSLLS:DisableSafeMode-on
				Если БезопасныйРежим() = Истина Тогда
					// BSLLS:DisableSafeMode-off
					УстановитьБезопасныйРежим(Ложь);
					// BSLLS:DisableSafeMode-on
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + XMLСтрока(Индекс) + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	// BSLLS:ExecuteExternalCodeInCommonModule-off
	Возврат Вычислить(ИмяМетода + "(" + ПараметрыСтрока + ")"); // АПК:488 Исполняемый код безопасен.
	// BSLLS:ExecuteExternalCodeInCommonModule-on
	
КонецФункции

// Аналог метода БСП. Вычисляет переданное выражение, предварительно устанавливая безопасный режим выполнения кода
// и безопасный режим разделения данных для всех разделителей, присутствующих в составе конфигурации.
//
// Параметры:
//  Выражение - Строка - выражение на встроенном языке 1С:Предприятия.
//  Параметры - Произвольный - контекст, который требуется для вычисления выражения.
//    В тексте выражения обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2" переданные в Параметры, как свойства.
//
// Возвращаемое значение:
//   Произвольный - результат вычисления выражения.
//
// Пример:
//
//  // Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
Функция ВычислитьВБезопасномРежиме(Знач Выражение, Знач Параметры = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ВычислитьВБезопасномРежиме(Выражение, Параметры);
	КонецЕсли;
	
	УстановитьБезопасныйРежим(Истина);
	
	Если ПодсистемаСуществует("ТехнологияСервиса.БазоваяФункциональность") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МассивРазделителей = МодульРаботаВМоделиСервиса.РазделителиКонфигурации();
	Иначе
		МассивРазделителей = Новый Массив;
	КонецЕсли;
	
	Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
		
		УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		
	КонецЦикла;
	
	Возврат Вычислить(Выражение);
	
КонецФункции

// Аналог метода БСП. Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - ПланОбменаСсылка
//           - СправочникСсылка
//           - Строка - ссылка на объект информационной базы,
//             представляющий объект-владелец сохраняемого пароля или строка до 128 символов.
//             Для объектов других типов в качестве владельца рекомендуется использовать ссылку на
//             элемент метаданных этого типа в справочнике ИдентификаторыОбъектовМетаданных
//             или ключ в виде строки с учетом имен подсистем.
//             Например, для БСП:
//               Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("РегистрСведений.АдресныеОбъекты");
//             если нужно 1 хранилище на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом";
//             если нужно более 1 хранилища на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом.<Уточнение>";
//  Данные  - Произвольный - данные помещаемые в безопасное хранилище. Неопределенно - удаляет все данные.
//            Для удаления данных по ключу следует использовать процедуру УдалитьДанныеИзБезопасногоХранилища.
//          - Структура - если параметр Ключ содержит Неопределено. Подробнее см. описание параметра Ключ
//  Ключ    - Строка       - ключ сохраняемых настроек, по умолчанию "Пароль".
//                           Ключ должен соответствовать правилам имен идентификаторов:
//                           1. Первым символом ключа должна быть буква или символ подчеркивания (_).
//                           2. Каждый из последующих символов может быть буквой, цифрой или символом подчеркивания (_). 
//            Неопределено - для добавления набора данных структурой, где ключ структуры - это имя ключа данных,
//            а значение - сохраняемые данные. Пример использования см. ниже.
//
// Пример:
//
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Логин, "Логин");
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Пароль);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
// 
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          ЛогинИПароль = Новый Структура;
//          ЛогинИПароль.Вставить("Логин", Логин);
//          ЛогинИПароль.Вставить("Пароль", Пароль);
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, ЛогинИПароль, Неопределено);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ = "Пароль") Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ);
		Возврат;
	КонецЕсли;
	
	пбп_ПереадресацияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец),
		пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Владелец, ТипЗнч(Владелец)));
	
	Если ЗначениеЗаполнено(Ключ) Тогда
		
		пбп_ПереадресацияКлиентСервер.Проверить(ТипЗнч(Ключ) = Тип("Строка"),
			пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|параметр должен содержать строку; передано значение: %3 (тип %4).'"),
			"Ключ", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Ключ, ТипЗнч(Ключ))); 
	
	Иначе
		
		пбп_ПереадресацияКлиентСервер.Проверить(ТипЗнч(Данные) = Тип("Структура"),
			пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|Если Ключ = Неопределено, то параметр должен содержать структуру; передано значение: %3 (тип %4).'"),
			"Данные", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Данные, ТипЗнч(Данные)));
	
	КонецЕсли;
	
	// Загулшка.
	// Перенаправление в хранилище общих настроек, не используется регистр сведений БезопасноеХранилищеДанных
	ХранилищеОбщихНастроекСохранить(Владелец, Ключ, Данные);
	Возврат;
	// Загулшка
	
КонецПроцедуры

// Аналог метода БСП. Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец    - ПланОбменаСсылка
//              - СправочникСсылка
//              - Строка - ссылка на объект информационной базы,
//                  представляющий объект-владелец сохраняемого пароля или уникальная строка(до 128 символов).
//  Ключи       - Строка - содержит список имен сохраненных данных, указанных через запятую.
//              - Неопределено - будут возвращены все сохраненные данные владельца.
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Произвольный, Структура, Неопределено - данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
// Пример:
//	Если ТекущийПользовательМожетИзменятьПароль Тогда
//		УстановитьПривилегированныйРежим(Истина);
//		Логин  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, "Логин");
//		Пароль = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка);
//		УстановитьПривилегированныйРежим(Ложь);
//	Иначе
//		Элементы.ГруппаЛогинИПароль.Видимость = Ложь;
//	КонецЕсли;
//	
//	УстановитьПривилегированныйРежим(Истина);
//	ЛогинИПароль  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, Неопределено);
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи, ОбщиеДанные);
	КонецЕсли;
	
	// Загулшка.
	// Перенаправление в хранилище общих настроек, не используется регистр сведений БезопасноеХранилищеДанных
	Результат = ХранилищеОбщихНастроекЗагрузить(Владелец, Ключи, ОбщиеДанные);
	Возврат Результат;
	// Загулшка
	
КонецФункции

// Аналог метода БСП. Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
//
// В фоновом задании длительной операции, если вызов выполнен вне транзакции,
// сообщение записывается в служебный регистр и отправляется сразу на клиент,
// если подключена система взаимодействия.
// В конце фонового задания длительной операции, а также при отправке прогресса,
// все сообщения извлекаются из очереди сообщений фонового задания,
// записываются в служебный регистр и отправляются сразу на клиент,
// если подключена система взаимодействия.
//
// АПК:142-выкл 4 необязательных параметра для совместимости 
// с устаревшей процедурой ОбщегоНазначенияКлиентСервер.СообщитьПользователю.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка - наименование реквизита формы.
//  ПутьКДанным - Строка - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено,	Знач Поле = "",
	Знач ПутьКДанным = "", Отказ = Ложь) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.СообщитьПользователю(ТекстСообщенияПользователю, КлючДанных, Поле, ПутьКДанным, Отказ);
		Возврат;
	КонецЕсли;
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Сообщение = пбп_ПереадресацияКлиентСервер.СообщениеПользователю(ТекстСообщенияПользователю,
		КлючДанных, Поле, ПутьКДанным, Отказ, ЭтоОбъект);
	
	Сообщение.Сообщить();
	
КонецПроцедуры

// Аналог метода БСП. Сокращает строку до нужной длины, при этом обрезанная часть хешируется,
// обеспечивая уникальность строки. Проверяет длину строки на входе и, в случае
// превышения максимальной длины, преобразует ее конец по алгоритму MD5 в
// уникальную строку из 32 символов.
//
// Параметры:
//  Строка            - Строка - исходная строка произвольной длины.
//  МаксимальнаяДлина - Число  - требуемое максимальное количество символов в строке,
//                               минимальное значение: 32.
// 
// Возвращаемое значение:
//   Строка - строка, не превышающая максимальную длину.
//
Функция СократитьСтрокуКонтрольнойСуммой(Строка, МаксимальнаяДлина) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.СократитьСтрокуКонтрольнойСуммой(Строка, МаксимальнаяДлина);
	КонецЕсли;
	
	Если МаксимальнаяДлина < 32 Тогда
		пбп_ПереадресацияКлиентСервер.Проверить(Ложь, 
			пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Параметр %1 не может быть меньше 32.'"),
				"МаксимальнаяДлина"), "ОбщегоНазначения.СократитьСтрокуКонтрольнойСуммой");
	КонецЕсли;
	
	Результат = Строка;
	Если СтрДлина(Строка) > МаксимальнаяДлина Тогда
		Результат = Лев(Строка, МаксимальнаяДлина - 32);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, МаксимальнаяДлина - 32 + 1));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

#Область ХранилищеНастроек

// Аналог метода БСП. Загружает настройку из хранилища общих настроек, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не существуют.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не существуют.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
			ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ХранилищеОбщихНастроекЗагрузить(
			КлючОбъекта,
			КлючНастроек,
			ЗначениеПоУмолчанию,
			ОписаниеНастроек,
			ИмяПользователя);
	КонецЕсли;
	
	Возврат ХранилищеЗагрузить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Аналог метода БСП. Сохраняет настройку в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек = Неопределено,
			ИмяПользователя = Неопределено,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ХранилищеОбщихНастроекСохранить(
			КлючОбъекта,
			КлючНастроек,
			Настройки,
			ОписаниеНастроек,
			ИмяПользователя,
			ОбновитьПовторноИспользуемыеЗначения);
		Возврат;
	КонецЕсли;
	
	ХранилищеСохранить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Настройки,
		ОписаниеНастроек,
		ИмяПользователя,
		ОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Аналог метода БСП. Удаляет настройку из хранилища общих настроек, как метод платформы Удалить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка
//                   - Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя);
		Возврат;
	КонецЕсли;
	
	ХранилищеУдалить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
	КонецПроцедуры
	
#КонецОбласти

// Аналог метода БСП. Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура
//            - ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//                       Допускается указание имени поля через точку, но при этом параметр КодЯзыка для такого поля
//                       учитываться не будет.
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то все реквизиты вернутся со 
//                                значением Неопределено; если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//              Если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//              Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты, ВыбратьРазрешенные, КодЯзыка);
	КонецЕсли;
	
	// Если передано имя предопределенного.
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ПредопределенноеЗначение(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			ТекстОшибки = пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный первый параметр %1 в функции %2:
				|%3'"), "Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", 
				ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ".");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			Если Не ПравоДоступа("Чтение", МетаданныеОбъекта) Тогда 
				ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недостаточно прав для работы с таблицей ""%1""'"), ПолноеИмяОбъектаМетаданных);
			КонецЕсли;
		КонецЕсли;
		
	Иначе // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значение должно быть ссылкой или именем предопределенного элемента.'"), 
				"Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта");
		КонецПопытки;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		Для Индекс = 0 По Реквизиты.ВГраница() Цикл
			Реквизиты[Индекс] = СокрЛП(Реквизиты[Индекс]);
		КонецЦикла;
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			СтруктураПолей.Вставить(КлючИЗначение.Ключ, СокрЛП(КлючИЗначение.Значение));
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			Реквизит = СокрЛП(Реквизит);
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"),
						"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра %1 в функции %2: %3.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
	
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	Если Тип("Структура") = ТипЗнч(Реквизиты)
		Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
		Реквизиты = Новый Массив;
		Для Каждого КлючИЗначение Из СтруктураПолей Цикл
			ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
			Реквизиты.Добавить(ИмяПоля);
		КонецЦикла;
	КонецЕсли;
	
	РеквизитыЧерезТочку = Новый Массив;
	Для Индекс = -Реквизиты.ВГраница() По 0 Цикл
		ИмяПоля = Реквизиты[-Индекс];
		Если СтрНайти(ИмяПоля, ".") Тогда
			РеквизитыЧерезТочку.Добавить(ИмяПоля);
			Реквизиты.Удалить(-Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Реквизиты) Тогда
		ЗначенияРеквизитовОбъекта = ЗначенияРеквизитовОбъектов(
			пбп_ПереадресацияКлиентСервер.ЗначениеВМассиве(Ссылка),
			Реквизиты, ВыбратьРазрешенные,
			КодЯзыка)[Ссылка];
		Если ЗначенияРеквизитовОбъекта <> Неопределено Тогда
			Для Каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Если СтрНайти(ИмяПоля, ".") = 0 И ЗначенияРеквизитовОбъекта.Свойство(ИмяПоля) Тогда
					Результат[КлючИЗначение.Ключ] = ЗначенияРеквизитовОбъекта[ИмяПоля];
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(РеквизитыЧерезТочку) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Реквизиты = РеквизитыЧерезТочку;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|&ТекстЗапросаПолей
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка";
	
	Если Не ВыбратьРазрешенные Тогда 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаПолей", ТекстЗапросаПолей);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты)
			Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Аналог меотда БСП Возвращает код основного языка информационной базы, например "ru".
// На котором программно записываются автогенерируемые строки в информационную базу.
// Например, при начальном заполнении информационной базы данными из макета, автогенерации комментария
// к проводке или определении значения параметра ИмяСобытия метода ЗаписьЖурналаРегистрации.
//
// Возвращаемое значение:
//  Строка
//
Функция КодОсновногоЯзыка() Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.КодОсновногоЯзыка();
	КонецЕсли;
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.Мультиязычность") Тогда
		МодульМультиязычностьСервер = ОбщийМодуль("МультиязычностьСервер");
		Возврат МодульМультиязычностьСервер.КодОсновногоЯзыка();
	КонецЕсли;
	
	Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	
КонецФункции

// Аналог метода БСП. Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Если передано имя несуществующего реквизита, то вызывается исключение "Поле объекта не существует". 
//
// Параметры:
//  Ссылки - Массив из ЛюбаяСсылка
//         - ФиксированныйМассив из ЛюбаяСсылка - ссылки на объекты.
//           Если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                       структуры. Например, "Код, Наименование, Родитель".
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗначенияРеквизитовОбъектов(Ссылки, Реквизиты, ВыбратьРазрешенные, КодЯзыка);
	КонецЕсли;
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Поле объекта должно быть указано.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Обращение через точку не поддерживается.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		КодЯзыка = СтрРазделить(КодЯзыка, "_", Истина)[0];
	КонецЕсли;
	
	РеквизитыТекстЗапроса = Реквизиты;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		Тип = ТипЗнч(Ссылка);
		Если СсылкиПоТипам[Тип] = Неопределено Тогда
			СсылкиПоТипам[Тип] = Новый Массив;
		КонецЕсли;
		ЭлементПоТипу = СсылкиПоТипам[Тип]; // Массив
		ЭлементПоТипу.Добавить(Ссылка);
	КонецЦикла;
	
	ТекстыЗапросов = Новый Массив;
	ПараметрыЗапроса = Новый Структура;
	
	ИменаОбъектовМетаданных = Новый Массив;
	
	Для Каждого СсылкиПоТипу Из СсылкиПоТипам Цикл
		Тип = СсылкиПоТипу.Ключ;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значения массива должны быть ссылками.'"), "Ссылки", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
		КонецЕсли;
		
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		ИменаОбъектовМетаданных.Добавить(ПолноеИмяОбъектаМетаданных);
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка,
			|	&Реквизиты
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В (&Ссылки)";
		Если Не ВыбратьРазрешенные Или ТекстыЗапросов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", РеквизитыТекстЗапроса);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Ссылки", "&" + ИмяПараметра); // @Query-part-1
		ПараметрыЗапроса.Вставить(ИмяПараметра, СсылкиПоТипу.Значение);
		
		ТекстыЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(ТекстыЗапросов, Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КодЯзыка", КодЯзыка);
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		СписокОшибок = Новый Массив;
		Для Каждого ПолноеИмяОбъектаМетаданных Из ИменаОбъектовМетаданных Цикл
			Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
			Если Результат.Ошибка Тогда 
				СписокОшибок.Добавить(Результат.ОписаниеОшибки);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СписокОшибок) Тогда
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов", СтрСоединить(СписокОшибок, Символы.ПС));
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
		
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Аналог метода БСП. Возвращает значения реквизита, прочитанного из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
// 
// Если передано имя несуществующего реквизита, то вызывается исключение "Поле объекта не существует". 
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//                                Допускается указание имени реквизита через точку, но при этом параметр КодЯзыка для
//                                такого реквизита учитываться не будет.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то возвращается Неопределено;
//                                если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Произвольный - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//                 Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//                 то возвращается Неопределено.
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные, КодЯзыка);
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Имя реквизита должно быть заполнено.'"), "ИмяРеквизита", "ОбщегоНазначения.ЗначениеРеквизитаОбъекта");
	КонецЕсли;
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные, КодЯзыка);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Аналог метода БСП. Возвращает ОбъектМетаданных, быстро найденный по полному имени.
// Более производительный аналог метода платформы Метаданные.НайтиПоПолномуИмени
// для корневых объектов метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, например, Справочник.Организации
//
// Возвращаемое значение:
//  ОбъектМетаданных - когда найден
//  Неопределено - когда не найден
//
Функция ОбъектМетаданныхПоПолномуИмени(ПолноеИмя) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ОбъектМетаданныхПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	
	Возврат ОбъектМетаданных;
	
КонецФункции

// Аналог метода БСП. Проверяет существование указанных реквизитов у объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура:
//   * Ошибка         - Булево - найдена ошибка.
//   * ОписаниеОшибки - Строка - описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.ПроверитьСуществованиеРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения);
	КонецЕсли;
	
	МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Несуществующий объект метаданных ""%1"".'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции

// Аналог метода БСП. Создает объект ОписаниеТипов, содержащий тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число - длина строки.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Строка.
//
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ОписаниеТипаСтрока(ДлинаСтроки);
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки));
	
КонецФункции

// Аналог метода БСП. Создает объект ОписаниеТипов, содержащий тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Число.
//
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, Знач ЗнакЧисла = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;
	
	Если ЗнакЧисла = Неопределено Тогда 
		ЗнакЧисла = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла));
	
КонецФункции

// Аналог метода БСП. Возвращает значение настройки рабочей даты для пользователя или текущей даты сеанса,
// если рабочая дата пользователя не задана.
//
// Параметры:
//  ИмяПользователя - Строка - имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//  Дата - значение настройки рабочей даты пользователя или текущая дата сеанса, если настройка не задана.
//
Функция ТекущаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ТекущаяДатаПользователя(ИмяПользователя);
	КонецЕсли;
	
	Возврат ТекущаяДатаСеанса();
	
КонецФункции

#Область СериализацияXML

// Аналог метода БСП. Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗначениеВСтрокуXML(Значение);
	КонецЕсли;
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Аналог метода БСП. Выполняет преобразование (десериализацию) XML-строки в значение.
// См. также ЗначениеВСтрокуXML.
//
// Параметры:
//  СтрокаXML - Строка - XML-строка, с сериализованным объектом..
//
// Возвращаемое значение:
//  Произвольный - значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗначениеИзСтрокиXML(СтрокаXML);
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

#КонецОбласти

// Аналог метода БСП. Возвращает менеджер объекта по полному имени объекта метаданных.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ОбработкаМенеджер, РегистрСведенийМенеджер - менеджер объекта.
// 
// Пример:
//  МенеджерСправочника = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("Справочник.Организации");
//  ПустаяСсылка = МенеджерСправочника.ПустаяСсылка();
//
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ   = ЧастиИмени[1];
	Иначе 
		Менеджер = Неопределено;
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		
		Если      ЧастиИмени.Количество() = 2 Тогда
			Менеджер = РегистрыРасчета;
			
		ИначеЕсли ЧастиИмени.Количество() = 4 Тогда
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда 
				Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
				ИмяОм = ИмяПодчиненногоОМ;
				
			Иначе 
				Менеджер = Неопределено;
			КонецЕсли;
			
		Иначе
			Менеджер = Неопределено;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
		
	Иначе
		Менеджер = Неопределено;
	КонецЕсли;
	
	Если Менеджер = Неопределено Тогда
		ПроверитьОбъектМетаданныхСуществует(ПолноеИмя);
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не имеет менеджера объекта.';
				|en = 'Metadata object %1 has no object manager.'"), ПолноеИмя);
	КонецЕсли;
	
	Попытка
		Возврат Менеджер[ИмяОМ];
	Исключение
		ПроверитьОбъектМетаданныхСуществует(ПолноеИмя);
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Аналог метода БСП. Возвращает менеджер объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
// См. также ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ОбработкаМенеджер, РегистрСведенийМенеджер - менеджер объекта.
//
// Пример:
//  МенеджерСправочника = ОбщегоНазначения.МенеджерОбъектаПоСсылке(СсылкаНаОрганизацию);
//  ПустаяСсылка = МенеджерСправочника.ПустаяСсылка();
//
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.МенеджерОбъектаПоСсылке(Ссылка);
	КонецЕсли;
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

#Область Данные

// Аналог метода БСП. Вычисляет контрольную сумму для произвольных данных по указанному алгоритму.
//
// Параметры:
//  Данные   - Произвольный - любое сериализуемое значение.
//  Алгоритм - ХешФункция   - алгоритм расчета контрольной суммы. По умолчанию, MD5.
// 
// Возвращаемое значение:
//  Строка - контрольная сумма строкой без пробелов (например 32 символа).
//
Функция КонтрольнаяСуммаСтрокой(Знач Данные, Знач Алгоритм = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.КонтрольнаяСуммаСтрокой(Данные, Алгоритм);
	КонецЕсли;
	
	Если Алгоритм = Неопределено Тогда
		Алгоритм = ХешФункция.MD5;
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(Алгоритм);
	Если ТипЗнч(Данные) <> Тип("Строка") И ТипЗнч(Данные) <> Тип("ДвоичныеДанные") Тогда
		Данные = ЗначениеВСтрокуXML(Данные);
	КонецЕсли;
	ХешированиеДанных.Добавить(Данные);
	
	Если ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("ДвоичныеДанные") Тогда 
		Результат = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	ИначеЕсли ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("Число") Тогда
		Результат = Формат(ХешированиеДанных.ХешСумма, "ЧГ=");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ТекущееОкружение

// Аналог метода БСП. Возвращает Истина, если текущий сеанс выполняется на сервере, работающем под управлением ОС Windows.
//
// Возвращаемое значение:
//  Булево - Истина, если сервер работает под управлением ОС Windows.
//
Функция ЭтоWindowsСервер() Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЭтоWindowsСервер();
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
	
КонецФункции

// Аналог метода БСП. Возвращает Истина, если текущий сеанс выполняется на сервере, работающем под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - Истина, если сервер работает под управлением ОС Linux.
//
Функция ЭтоLinuxСервер() Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЭтоLinuxСервер();
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

#КонецОбласти // ТекущееОкружение

#Область Прочее

// Аналог метода БСП. Выполняет проверки перед выполнением обработчика регламентного задания и прерывает выполнение,
// если его запуск в данный момент невозможен, например:
//  - еще не завершено обновление программы;
//  - запуск через консоль или другим способом, минуя включение функциональной опции 
//    (если регламентное задание зависит от функциональных опций);
//  - попытка выполнения задания, работающего с внешними ресурсами в копии информационной базы.
//
// Параметры:
//  РегламентноеЗадание - ОбъектМетаданныхРегламентноеЗадание - регламентное задание,
//    из которого вызывается данная процедура.
//
// Пример:
// ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.<ИмяРегламентногоЗадания>);
//
Процедура ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание = Неопределено) Экспорт
	
	Результат = ПереадресацияМодуляОбщегоНазначения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти // Прочее

#КонецОбласти

#Область ФайловаяСистема

// Аналог метода БСП. Удаляет временный файл.
// 
// Выбрасывает исключение, если передано имя не временного файла.
// 
// Если временный файл не может быть удален (например, он занят каким-то процессом),
// то в журнал регистрации записывается соответствующее предупреждение, а процедура завершается.
//
// Для совместного использования с методом ПолучитьИмяВременногоФайла, 
// после окончания работы с временным файлом.
//
// Параметры:
//   Путь - Строка - полный путь к временному файлу.
//
Процедура УдалитьВременныйФайл(Знач Путь) Экспорт
	
	Результат = ПереадресацияМодуляФайловаяСистема();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.УдалитьВременныйФайл(Путь);
		Возврат;
	КонецЕсли;
	
	Если НЕ ЭтоИмяВременногоФайла(Путь) Тогда
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра %1 в %2:
				|Файл не является временным ""%3"".'"), 
			"Путь", "ФайловаяСистема.УдалитьВременныйФайл", Путь);
	КонецЕсли;
	
	УдалитьВременныеФайлы(Путь);
	
КонецПроцедуры

#Область ЗапускВнешнихПриложений

// Аналог метода БСП. Конструктор параметров для ФайловаяСистема.ЗапуститьПрограмму.
//
// Возвращаемое значение:
//  Структура:
//    * ТекущийКаталог - Строка - задает текущий каталог запускаемого приложения.
//    * ДождатьсяЗавершения - Булево - Ложь - дожидаться завершения запущенного приложения 
//         перед продолжением работы.
//    * ПолучитьПотокВывода - Булево - Ложь - результат, направленный в поток stdout,
//         если не указан ДождатьсяЗавершения - игнорируется.
//    * ПолучитьПотокОшибок - Булево - Ложь - ошибки, направленные в поток stderr,
//         если не указан ДождатьсяЗавершения - игнорируется.
//    * КодировкаПотоков - КодировкаТекста
//                       - Строка - кодировка, используемая для чтения stdout и stderr.
//         По умолчанию используется для Windows "CP866", для остальных - "UTF-8".
//    * КодировкаИсполнения - Строка
//                          - Число - кодировка, устанавливаемая в Windows с помощью команды chcp,
//             возможные значения: "OEM", "CP866", "UTF8" или номер кодовой страницы.
//         В Linux устанавливается переменной окружения "LANGUAGE" для конкретной команды,
//             возможные значения можно определить выполнив команду "locale -a", например "ru_RU.UTF-8".
//         В MacOS игнорируется.
//
Функция ПараметрыЗапускаПрограммы() Экспорт
	
	Результат = ПереадресацияМодуляФайловаяСистема();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ПараметрыЗапускаПрограммы();
	КонецЕсли;
	
	Параметры = Новый Структура;
	Параметры.Вставить("ТекущийКаталог", "");
	Параметры.Вставить("ДождатьсяЗавершения", Ложь);
	Параметры.Вставить("ПолучитьПотокВывода", Ложь);
	Параметры.Вставить("ПолучитьПотокОшибок", Ложь);
	Параметры.Вставить("КодировкаПотоков", Неопределено);
	Параметры.Вставить("КодировкаИсполнения", Неопределено);
	
	Возврат Параметры;
	
КонецФункции

// Запускает внешнюю программу на исполнение (например, *.exe, *bat), 
// или системную команду (например, ping, tracert или traceroute, обращаться к rac-клиенту),
// Позволяет также получать код возврата и значения потоков вывода (stdout) и ошибок (stderr)
//
// При запуске внешней программы в пакетном режиме поток вывода и поток ошибок может возвращаться на не ожидаемом языке. 
// Для того чтобы передать внешней программе язык, на котором ожидается результат следует:
// - указать язык в параметре запуска этой программы (если такой параметр предусмотрен). 
//   Например, в пакетном режиме платформы 1С:Предприятие предусмотрен ключ "/L en";
// - в других случаях явно установить кодировку исполнения пакетной команды.
//   См. свойство КодировкаИсполнения возвращаемого значения ФайловаяСистема.ПараметрыЗапускаПрограммы. 
//
// Параметры:
//  КомандаЗапуска - Строка - командная строка для запуска программы.
//                 - Массив - первый элемент массива, путь к исполняемому приложению, 
//                            остальные элементы массива - это передаваемые параметры,
//                            массив соответствует тому, который получит вызываемая программа в argv.
//  ПараметрыЗапускаПрограммы - см. ФайловаяСистема.ПараметрыЗапускаПрограммы
//
// Возвращаемое значение:
//  Структура:
//    * КодВозврата - Число  - код возврата программы;
//    * ПотокВывода - Строка - результат работы программы, направленный в поток stdout;
//    * ПотокОшибок - Строка - ошибки исполнения программы, направленные в поток stderr.
//
// Пример:
//	// Простой запуск
//	ФайловаяСистема.ЗапуститьПрограмму("calc");
//	
//	// Запуск с ожиданием завершения
//	ПараметрыЗапускаПрограммы = ФайловаяСистема.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
//	ФайловаяСистема.ЗапуститьПрограмму("C:\Program Files\1cv8\common\1cestart.exe", 
//		ПараметрыЗапускаПрограммы);
//	
//	// Запуск с ожиданием завершения и получением потока вывода
//	ПараметрыЗапускаПрограммы = ФайловаяСистема.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
//	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
//	Результат = ФайловаяСистема("ping 127.0.0.1 -n 5", ПараметрыЗапускаПрограммы);
//	ОбщегоНазначений.СообщитьПользователю(Результат.ПотокВывода);
//
//	// Запуск с ожиданием завершения и получением потока вывода и с конкатенацией команды запуска
//	ПараметрыЗапускаПрограммы = ФайловаяСистема.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
//	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
//	КомандаЗапуска = Новый Массив;
//	КомандаЗапуска.Добавить("ping");
//	КомандаЗапуска.Добавить("127.0.0.1");
//	КомандаЗапуска.Добавить("-n");
//	КомандаЗапуска.Добавить(5);
//	Результат = ФайловаяСистема.ЗапуститьПрограмму(КомандаЗапуска, ПараметрыЗапускаПрограммы);
//	ОбщегоНазначений.СообщитьПользователю(Результат.ПотокВывода);
//
Функция ЗапуститьПрограмму(Знач КомандаЗапуска, ПараметрыЗапускаПрограммы = Неопределено) Экспорт 
	
	Результат = ПереадресацияМодуляФайловаяСистема();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ЗапуститьПрограмму(КомандаЗапуска, ПараметрыЗапускаПрограммы);
	КонецЕсли;
	
	СтрокаКоманды = пбп_ПереадресацияКлиентСервер.БезопаснаяСтрокаКоманды(КомандаЗапуска);
	
	Если ПараметрыЗапускаПрограммы = Неопределено Тогда 
		ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	КонецЕсли;
	
	ТекущийКаталог = ПараметрыЗапускаПрограммы.ТекущийКаталог;
	ДождатьсяЗавершения = ПараметрыЗапускаПрограммы.ДождатьсяЗавершения;
	ПолучитьПотокВывода = ПараметрыЗапускаПрограммы.ПолучитьПотокВывода;
	ПолучитьПотокОшибок = ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок;
	КодировкаПотоков = ПараметрыЗапускаПрограммы.КодировкаПотоков;
	КодировкаИсполнения = ПараметрыЗапускаПрограммы.КодировкаИсполнения;
	
	ПроверитьТекущийКаталог(СтрокаКоманды, ТекущийКаталог);
	
	Если ДождатьсяЗавершения Тогда
		Если ПолучитьПотокВывода Тогда
			// BSLLS:MissingTemporaryFileDeletion-off
			ИмяФайлаПотокаВывода = ПолучитьИмяВременногоФайла("stdout.tmp");
			// BSLLS:MissingTemporaryFileDeletion-on
			СтрокаКоманды = СтрокаКоманды + " > """ + ИмяФайлаПотокаВывода + """";
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда
			// BSLLS:MissingTemporaryFileDeletion-off
			ИмяФайлаПотокаОшибок = ПолучитьИмяВременногоФайла("stderr.tmp");
			// BSLLS:MissingTemporaryFileDeletion-on
			СтрокаКоманды = СтрокаКоманды + " 2>""" + ИмяФайлаПотокаОшибок + """";
		КонецЕсли;
	КонецЕсли;
	
	Если КодировкаПотоков = Неопределено Тогда
		КодировкаПотоков = КодировкаСтандартныхПотоков();
	КонецЕсли;
	
	// Для cmd не всегда активна текущая кодовая страница, поэтому всегда задаем по-умолчанию.
	Если КодировкаИсполнения = Неопределено И пбп_Переадресация.ЭтоWindowsСервер() Тогда
		КодировкаИсполнения = "CP866";
	КонецЕсли;
	
	КодВозврата = Неопределено;
	
	Если пбп_Переадресация.ЭтоWindowsСервер() Тогда
		
		СтрокаКоманды = пбп_ПереадресацияКлиентСервер.СтрокаЗапускаКомандыWindows(
			СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодировкаИсполнения);
		
		Если пбп_Переадресация.ИнформационнаяБазаФайловая() Тогда
			// В файловой информационной базе показывать окно консоли не следует и в серверном контексте.
			Оболочка = Новый COMОбъект("Wscript.Shell");
			КодВозврата = Оболочка.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			Оболочка = Неопределено;
		Иначе
			// BSLLS:ExternalAppStarting-off
			ЗапуститьПриложение(СтрокаКоманды, , ДождатьсяЗавершения, КодВозврата);
			// BSLLS:ExternalAppStarting-on
		КонецЕсли;
		
	Иначе
		
		Если пбп_Переадресация.ЭтоLinuxСервер() И ЗначениеЗаполнено(КодировкаИсполнения) Тогда
			СтрокаКоманды = "LANGUAGE=" + КодировкаИсполнения + " " + СтрокаКоманды;
		КонецЕсли;
		
		// BSLLS:ExternalAppStarting-off
		ЗапуститьПриложение(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодВозврата);
		// BSLLS:ExternalAppStarting-on
	КонецЕсли;
	
	ПотокВывода = "";
	ПотокОшибок = "";
	
	Если ДождатьсяЗавершения Тогда
		Если ПолучитьПотокВывода Тогда
			ПотокВывода = ПрочитатьФайлЕслиСуществует(ИмяФайлаПотокаВывода, КодировкаПотоков);
			УдалитьВременныйФайл(ИмяФайлаПотокаВывода);
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда 
			ПотокОшибок = ПрочитатьФайлЕслиСуществует(ИмяФайлаПотокаОшибок, КодировкаПотоков);
			УдалитьВременныйФайл(ИмяФайлаПотокаОшибок);
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("КодВозврата", КодВозврата);
	Результат.Вставить("ПотокВывода", ПотокВывода);
	Результат.Вставить("ПотокОшибок", ПотокОшибок);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СерверныеОповещения

// Аналог метода БСП. Добавляет серверное оповещение в очередь для доставки на клиент.
// Оповещение доставляется через систему взаимодействия,
// либо забирается в рамках общего серверного вызова.
//
// Параметры:
//  ИмяОповещения - Строка - смотри НовоеСерверноеОповещение.Имя.
//  
//  Результат - Произвольный - произвольное сериализуемое значение,
//             которое будет отправлено в составе оповещения на клиент
//             (должны быть как можно меньшего размера, желательно не более 1 Кб).
//
//  Адресаты - Неопределено - все пользователи (и соответственно все сеансы).
//               Если указано незаполненное соответствие, тогда возврат.
//           - Соответствие из КлючИЗначение:
//              * Ключ - УникальныйИдентификатор - идентификатор пользователя ИБ.
//              * Значение - Массив из см. СерверныеОповещения.КлючСеанса
//
//  ОтправитьСразу - Булево - если Истина, попытаться сразу отправить сообщение
//               через систему взаимодействия перед добавлением в очередь.
//               Отправка сразу не допускается из обработчиков ПриОтправкеСерверногоОповещения.
//               Следует учесть (особенно при вызове в транзакции), что неудачное обращение
//               к системе взаимодействия может занимать (3-5 сек)*2, а удачное не менее (50 мс)*2.
//
Процедура ОтправитьСерверноеОповещение(ИмяОповещения, Результат, Адресаты, ОтправитьСразу = Ложь) Экспорт
	
	Результат = ПереадресацияМодуляСерверныеОповещения();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.ОтправитьСерверноеОповещение(ИмяОповещения, Результат, Адресаты, ОтправитьСразу);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область РегламентныеЗаданияСервер

// Аналог метода БСП. В локальном режиме работы возвращает регламентные задания, соответствующие отбору.
// В модели сервиса - таблицу значений, в которой содержится описание найденных заданий
// в справочнике ОчередьЗаданий.
//
// Параметры:
//  Отбор - Структура - со свойствами: 
//          1) Общие для любого режима работы:
//             * УникальныйИдентификатор - УникальныйИдентификатор - идентификатор регламентного задания в локальном
//                                         режиме работы или идентификатор ссылки задания очереди в модели сервиса.
//                                       - Строка - строка уникального идентификатора регламентного задания в локальном
//                                         режиме работы или идентификатор ссылки задания очереди в модели сервиса.
//                                       - СправочникСсылка.ОчередьЗаданий - идентификатор задания
//                                            очереди в модели сервиса.
//                                       - СтрокаТаблицыЗначений из см. НайтиЗадания
//             * Метаданные              - ОбъектМетаданныхРегламентноеЗадание - метаданные регламентного задания.
//                                       - Строка - имя метаданных регламентного задания.
//             * Использование           - Булево - если Истина, задание включено.
//             * Ключ                    - Строка - прикладной идентификатор задания.
//          2) Возможные ключи только локального режима:
//             * Наименование            - Строка - наименование регламентного задания.
//             * Предопределенное        - Булево - если Истина, регламентное задание определено в метаданных.
//          3) Возможные ключи только для модели сервиса:
//             * ИмяМетода               - Строка - имя метода (или псевдоним) обработчика очереди задании.
//             * ОбластьДанных           - Число - значение разделителя области данных задания.
//             * СостояниеЗадания        - ПеречислениеСсылка.СостоянияЗаданий - состояние задания очереди.
//             * Шаблон                  - СправочникСсылка.ШаблоныЗаданийОчереди - шаблон задания, используется только
//                                            для разделенных заданий очереди.
//
// Возвращаемое значение:
//     Массив из РегламентноеЗадание - в локальном режиме работы массив регламентных заданий.
//     ТаблицаЗначений - в модели сервиса с колонками:
//        * Использование                - Булево - если Истина, задание включено.
//        * Ключ                         - Строка - прикладной идентификатор задания.
//        * Параметры                    - Массив - параметры, передаваемые в обработчик задания.
//        * Расписание                   - РасписаниеРегламентногоЗадания - расписание задания.
//        * УникальныйИдентификатор      - СправочникСсылка.ОчередьЗаданий - идентификатор задания
//                                            очереди в модели сервиса.
//        * ЗапланированныйМоментЗапуска - Дата - дата и время запланированного запуска задания
//                                         (в часовом поясе области данных).
//        * ИмяМетода                    - Строка - имя метода (или псевдоним) обработчика очереди задании.
//        * ОбластьДанных                - Число - значение разделителя области данных задания.
//        * СостояниеЗадания             - ПеречислениеСсылка.СостоянияЗаданий - состояние задания очереди.
//        * Шаблон                       - СправочникСсылка.ШаблоныЗаданийОчереди - шаблон задания,
//                                            используется только для разделенных заданий очереди.
//        * ЭксклюзивноеВыполнение       - Булево - при установленном флаге задание будет выполнено 
//                                                  даже при установленной блокировке начала сеансов в области
//                                                  данных. Так же если в области есть задания с таким флагом
//                                                  сначала будут выполнены они.
//        * ИнтервалПовтораПриАварийномЗавершении - Число - интервал в секундах, через который нужно перезапускать
//                                                          задание в случае его аварийного завершения.
//        * КоличествоПовторовПриАварийномЗавершении - Число - количество повторов при аварийном завершении задания.
//
Функция НайтиЗадания(Отбор) Экспорт
	
	Результат = ПереадресацияМодуляРегламентныеЗаданияСервер();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.НайтиЗадания(Отбор);
	КонецЕсли;
	
	СписокЗаданий = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Отбор);
	
	Возврат СписокЗаданий;
	
КонецФункции

// Аналог метода БСП. Удаляет задание из очереди или регламентное.
//
// Параметры:
//  Идентификатор - ОбъектМетаданных - объект метаданных регламентного задания для поиска
//                                     непредопределенного регламентного задания.
//                - Строка - имя метаданных предопределенного регламентного задания в любом режиме работы
//                           или строка уникального идентификатора регламентного задания в локальном режиме работы
//                           или строка уникального идентификатора ссылки задания очереди в модели сервиса.
//                - УникальныйИдентификатор - идентификатор регламентного задания в локальном режиме работы.
//                           или идентификатор ссылки задания очереди в модели сервиса.
//                - РегламентноеЗадание - регламентное задание, уникальный идентификатор которого используется 
//                  для определения удаляемого экземпляра регламентного задания в локальном режиме работы.
//                - СправочникСсылка.ОчередьЗаданий - идентификатор задания очереди в модели сервиса.
//                - СтрокаТаблицыЗначений из см. НайтиЗадания
//
Процедура УдалитьЗадание(Знач Идентификатор) Экспорт
	
	Результат = ПереадресацияМодуляРегламентныеЗаданияСервер();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.УдалитьЗадание(Идентификатор);
		Возврат;
	КонецЕсли;
	
	Идентификатор = УточненныйИдентификаторЗадания(Идентификатор);
	
	УдалитьРегламентноеЗадание(Идентификатор);
	
КонецПроцедуры

// Аналог метода БСП. Добавляет новое задание в очередь или регламентное.
// 
// Параметры: 
//  Параметры - Структура - параметры добавляемого задания, возможные свойства:
//   * Использование - Булево - Истина, если регламентное задание должно выполняться автоматически согласно расписанию. 
//   * Метаданные    - ОбъектМетаданныхРегламентноеЗадание - обязательно для указания. Объект метаданных, на основе 
//                              которого будет создано регламентное задание.
//   * Параметры     - Массив - параметры регламентного задания. Количество и состав параметров должны соответствовать 
//                              параметрам метода регламентного задания.
//   * Ключ          - Строка - прикладной идентификатор регламентного задания.
//   * ИнтервалПовтораПриАварийномЗавершении - Число - интервал в секундах, через который нужно перезапускать задание 
//                              в случае его аварийного завершения.
//   * Расписание    - РасписаниеРегламентногоЗадания - расписание задания.
//   * КоличествоПовторовПриАварийномЗавершении - Число - количество повторов при аварийном завершении задания.
//
// Возвращаемое значение:
//  РегламентноеЗадание - в локальном режиме работы.
//  СтрокаТаблицыЗначений из см. НайтиЗадания
// 
Функция ДобавитьЗадание(Параметры) Экспорт
	
	Результат = ПереадресацияМодуляРегламентныеЗаданияСервер();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ДобавитьЗадание(Параметры);
	КонецЕсли;
	
	Задание = ДобавитьРегламентноеЗадание(Параметры);
	
	Возврат Задание;
	
КонецФункции

// Аналог метода БСП. Добавляет новое регламентное задание (без учета очереди заданий модели сервиса).
// 
// Параметры: 
//  Параметры - Структура - параметры добавляемого задания, возможные свойства:
//   * Использование - Булево - Истина, если регламентное задание должно выполняться автоматически согласно расписанию. 
//   * Метаданные    - ОбъектМетаданныхРегламентноеЗадание - обязательно для указания. Объект метаданных, на основе 
//                              которого будет создано регламентное задание.
//   * Параметры     - Массив - параметры регламентного задания. Количество и состав параметров должны соответствовать 
//                              параметрам метода регламентного задания.
//   * Ключ          - Строка - прикладной идентификатор регламентного задания.
//   * ИнтервалПовтораПриАварийномЗавершении - Число - интервал в секундах, через который нужно перезапускать задание 
//                              в случае его аварийного завершения.
//   * Расписание    - РасписаниеРегламентногоЗадания - расписание задания.
//   * КоличествоПовторовПриАварийномЗавершении - Число - количество повторов при аварийном завершении задания.
//
// Возвращаемое значение:
//  РегламентноеЗадание
//
Функция ДобавитьРегламентноеЗадание(Параметры) Экспорт
	
	Результат = ПереадресацияМодуляРегламентныеЗаданияСервер();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ДобавитьРегламентноеЗадание(Параметры);
	КонецЕсли;
	
	МетаданныеЗадания = Параметры.Метаданные;
	Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(МетаданныеЗадания);
	
	Если Параметры.Свойство("Наименование") Тогда
		Задание.Наименование = Параметры.Наименование;
	Иначе
		Задание.Наименование = МетаданныеЗадания.Наименование;
	КонецЕсли;
	
	Если Параметры.Свойство("Использование") Тогда
		Задание.Использование = Параметры.Использование;
	Иначе
		Задание.Использование = МетаданныеЗадания.Использование;
	КонецЕсли;
	
	Если Параметры.Свойство("Ключ") Тогда
		Задание.Ключ = Параметры.Ключ;
	Иначе
		Задание.Ключ = МетаданныеЗадания.Ключ;
	КонецЕсли;
	
	Если Параметры.Свойство("ИмяПользователя") Тогда
		Задание.ИмяПользователя = Параметры.ИмяПользователя;
	КонецЕсли;
	
	Если Параметры.Свойство("ИнтервалПовтораПриАварийномЗавершении") Тогда
		Задание.ИнтервалПовтораПриАварийномЗавершении = Параметры.ИнтервалПовтораПриАварийномЗавершении;
	Иначе
		Задание.ИнтервалПовтораПриАварийномЗавершении = МетаданныеЗадания.ИнтервалПовтораПриАварийномЗавершении;
	КонецЕсли;
	
	Если Параметры.Свойство("КоличествоПовторовПриАварийномЗавершении") Тогда
		Задание.КоличествоПовторовПриАварийномЗавершении = Параметры.КоличествоПовторовПриАварийномЗавершении;
	Иначе
		Задание.КоличествоПовторовПриАварийномЗавершении = МетаданныеЗадания.КоличествоПовторовПриАварийномЗавершении;
	КонецЕсли;
	
	Если Параметры.Свойство("Параметры") Тогда
		Задание.Параметры = Параметры.Параметры;
	КонецЕсли;
	
	Если Параметры.Свойство("Расписание") Тогда
		Задание.Расписание = Параметры.Расписание;
	КонецЕсли;
	
	Задание.Записать();
	
	Возврат Задание;
	
КонецФункции

#КонецОбласти

#Область Пользователи

// Аналог метода БСП. Возвращает текущего пользователя.
//  Рекомендуется использовать в коде, который не поддерживает работу с внешними пользователями.
//
//  Если вход в сеанс выполнил внешний пользователь, тогда будет вызвано исключение.
//
// Возвращаемое значение:
//  СправочникСсылка.Пользователи - пользователь.
//
Функция ТекущийПользователь() Экспорт
	
	Результат = ПереадресацияМодуляПользователи();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ТекущийПользователь();
	КонецЕсли;
	
	Возврат пбп_ПереадресацияКлиентСервер.ТекущийПользователь(АвторизованныйПользователь());
	
КонецФункции

// Аналог метода БСП. Возвращает пользователя ИБ по ссылке справочника Пользователи или ВнешниеПользователи.
//  Для поиска требуются административные права. Если административных прав нет,
// допустимо искать только пользователя для текущего пользователя ИБ.
// 
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи
//               - СправочникСсылка.ВнешниеПользователи
//
// Возвращаемое значение:
//  ПользовательИнформационнойБазы - если найден.
//  Неопределено - если пользователь ИБ не существует.
//
Функция НайтиПоСсылке(Пользователь) Экспорт
	
	Результат = ПереадресацияМодуляПользователи();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.НайтиПоСсылке(Пользователь);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Аналог метода БСП. Только для внутреннего использования.
//
// Возвращаемое значение:
//  Неопределено
//
Функция АвторизованныйПользователь() Экспорт
	
	Результат = ПереадресацияМодуляПользователи();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.АвторизованныйПользователь();
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область ПолучениеФайловИзИнтернета

// Аналог метода БСП. Возвращает объект ИнтернетПрокси для доступа в Интернет.
// Допустимые протоколы для создания ИнтернетПрокси http, https, ftp и ftps.
//
// Параметры:
//    URLИлиПротокол - Строка - url в формате [Протокол://]<Сервер>/<Путь к файлу на сервере>,
//                              либо идентификатор протокола (http, ftp, ...).
//
// Возвращаемое значение:
//    ИнтернетПрокси - описывает параметры прокси-серверов для различных протоколов.
//                     Если не удалось распознать схему сетевой протокол,
//                     то будет создать прокси на основании протокола HTTP.
//
Функция ПолучитьПрокси(Знач URLИлиПротокол) Экспорт
	
	Результат = ПереадресацияМодуляПолучениеФайловИзИнтернета();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.ПолучитьПрокси(URLИлиПротокол);
	КонецЕсли;
	
	НастройкиПрокси = пбп_Переадресация.ХранилищеОбщихНастроекЗагрузить("НастройкаПроксиСервера", "");
	Возврат НовыйИнтернетПрокси(НастройкиПрокси, URLИлиПротокол);
	
КонецФункции

// Аналог метода БСП. Возвращает прокси по настройкам НастройкаПроксиСервера для заданного протокола Протокол.
//
// Параметры:
//   НастройкаПроксиСервера - Соответствие из КлючИЗначение:
//    * Ключ - Строка - см. ниже список возможных ключей.
//    * Значение - Произвольный
//    ИспользоватьПрокси - Булево - использовать ли прокси-сервер.
//    НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов.
//    НеИспользоватьПроксиДляАдресов - Массив из Строка
//    ИспользоватьСистемныеНастройки - Булево - использовать ли системные настройки прокси-сервера.
//    Сервер       - Строка - адрес прокси-сервера.
//    Порт         - Строка - порт прокси-сервера.
//    Пользователь - Строка - имя пользователя для авторизации на прокси-сервере.
//    Пароль       - Строка - пароль пользователя.
//    ИспользоватьАутентификациюОС - Булево - признак использования аутентификации средствами операционной системы.
//   URLИлиПротокол - Строка - адрес ресурса или протокол, для которого устанавливаются параметры прокси сервера,
//                             например "https://1c.ru", "http", "https", "ftp", "ftps".
//
// Возвращаемое значение:
//   ИнтернетПрокси
//
Функция НовыйИнтернетПрокси(НастройкаПроксиСервера, URLИлиПротокол) Экспорт
	
	Результат = ПереадресацияМодуляПолучениеФайловИзИнтернета();
	Если Результат.МодульСуществует Тогда
		Возврат Результат.Модуль.НовыйИнтернетПрокси(НастройкаПроксиСервера, URLИлиПротокол);
	КонецЕсли;
	
	Если НастройкаПроксиСервера = Неопределено Тогда
		// Системные установки прокси-сервера.
		Возврат Неопределено;
	КонецЕсли;
	
	ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
	Если Не ИспользоватьПрокси Тогда
		// Не использовать прокси-сервер.
		Возврат Новый ИнтернетПрокси(Ложь);
	КонецЕсли;
	
	ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
	Если ИспользоватьСистемныеНастройки Тогда
		// Системные настройки прокси-сервера.
		Возврат Новый ИнтернетПрокси(Истина);
	КонецЕсли;
	
	ИспользоватьАутентификациюОС = НастройкаПроксиСервера.Получить("ИспользоватьАутентификациюОС");
	ИспользоватьАутентификациюОС = ?(ИспользоватьАутентификациюОС = Истина, Истина, Ложь);

	ДополнительныеНастройки = НастройкаПроксиСервера.Получить("ДополнительныеНастройкиПрокси");
	Если ТипЗнч(ДополнительныеНастройки) <> Тип("Соответствие") Тогда
		ДополнительныеНастройки = Новый Соответствие;
	КонецЕсли;
	
	// Настройки прокси-сервера, заданные вручную.
	Прокси = Новый ИнтернетПрокси;
	
	Протоколы = СтрРазделить("http,https,ftp,ftps", ",", Ложь);
	Для Каждого Протокол Из Протоколы Цикл
		АдресСервера = НастройкаПроксиСервера["Сервер"];
		Порт = НастройкаПроксиСервера["Порт"];
		
		ПроксиПоПротоколу = ДополнительныеНастройки[Протокол];
		Если ТипЗнч(ПроксиПоПротоколу) = Тип("Структура") Тогда
			АдресСервера = ПроксиПоПротоколу.Адрес;
			Порт = ПроксиПоПротоколу.Порт;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(Порт) Тогда
			Порт = Неопределено;
		КонецЕсли;
		
		Прокси.Установить(Протокол, АдресСервера, Порт, 
			НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"], ИспользоватьАутентификациюОС);
	КонецЦикла;
	
	Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
	
	АдресаИсключений = НастройкаПроксиСервера.Получить("НеИспользоватьПроксиДляАдресов");
	Если ТипЗнч(АдресаИсключений) = Тип("Массив") Тогда
		Для каждого АдресИсключения Из АдресаИсключений Цикл
			Прокси.НеИспользоватьПроксиДляАдресов.Добавить(АдресИсключения);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область МодульПереадресацииПоПодсистемам

Функция ПереадресацияМодуляЖурналРегистрации()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("ЖурналРегистрации");
КонецФункции

Функция ПереадресацияМодуляОбщегоНазначения()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("ОбщегоНазначения");
КонецФункции

Функция ПереадресацияМодуляСерверныеОповещения()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("СерверныеОповещения");
КонецФункции

Функция ПереадресацияМодуляРегламентныеЗаданияСервер()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("РегламентныеЗаданияСервер");
КонецФункции

Функция ПереадресацияМодуляПользователи()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("Пользователи");
КонецФункции

Функция ПереадресацияМодуляПолучениеФайловИзИнтернета()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("ПолучениеФайловИзИнтернета");
КонецФункции

Функция ПереадресацияМодуляФайловаяСистема()
	Возврат пбп_ПереадресацияПовтИсп.ОпределитьМодульПереадресации("ФайловаяСистема");
КонецФункции

#КонецОбласти

#Область ПереадресацияМетодов

#Область ФайловаяСистема

// Аналог метода БСП.
//
Процедура УдалитьВременныеФайлы(Знач Путь)
	
	Попытка
		УдалитьФайлы(Путь);
	Исключение
		пбп_Переадресация.ДобавитьСообщениеДляЖурналаРегистрации(
			НСтр("ru = 'Стандартные подсистемы'", пбп_Переадресация.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, , ,
				пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось удалить временный файл ""%1"" по причине:
						|%2'"),
					Путь,
					ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
	КонецПопытки;
	
КонецПроцедуры

// Аналог метода БСП.
//
Функция ЭтоИмяВременногоФайла(Путь)
	
	// Ожидается, что Путь получен методом ПолучитьИмяВременногоФайла().
	// Перед проверкой разворачиваем слэши в одну сторону.
	Возврат СтрНачинаетсяС(СтрЗаменить(Путь, "/", "\"), СтрЗаменить(КаталогВременныхФайлов(), "/", "\"));
	
КонецФункции

#Область ЗапуститьПрограмму

// Аналог метода БСП.
//
Процедура ПроверитьТекущийКаталог(СтрокаКоманды, ТекущийКаталог)
	
	Если Не ПустаяСтрока(ТекущийКаталог) Тогда 
		
		ФайлИнфо = Новый Файл(ТекущийКаталог);
		
		Если Не ФайлИнфо.Существует() Тогда
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось запустить программу
				           |%1
				           |по причине:
				           |Не существует каталог %2
				           |%3'"),
				СтрокаКоманды, "ТекущийКаталог", ТекущийКаталог);
		КонецЕсли;
		
		Если Не ФайлИнфо.ЭтоКаталог() Тогда 
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось запустить программу
				           |%1
				           |по причине:
				           |%2 не является каталогом 
				           |%3'"),
				СтрокаКоманды, "ТекущийКаталог", ТекущийКаталог);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Аналог метода БСП.
//
Функция ПрочитатьФайлЕслиСуществует(Путь, Кодировка)
	
	Результат = Неопределено;
	ФайлИнфо = Новый Файл(Путь);
	
	Если ФайлИнфо.Существует() Тогда 
		
		ЧтениеПотокаОшибок = Новый ЧтениеТекста(Путь, Кодировка);
		Результат = ЧтениеПотокаОшибок.Прочитать();
		ЧтениеПотокаОшибок.Закрыть();
		
	КонецЕсли;
	
	Если Результат = Неопределено Тогда 
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Аналог метода БСП. Возвращает кодировку стандартных поток вывода и ошибок, используемую в текущей ОС.
//
// Возвращаемое значение:
//  КодировкаТекста
//
Функция КодировкаСтандартныхПотоков()
	
	Если пбп_Переадресация.ЭтоWindowsСервер() Тогда
		Кодировка = "CP866";
	Иначе
		Кодировка = "UTF-8";
	КонецЕсли;
	
	Возврат Кодировка;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область РегламентныеЗаданияСервер

// Аналог метода БСП.
//
Функция УточненныйИдентификаторЗадания(Знач Идентификатор)
	
	Если ТипЗнч(Идентификатор) = Тип("РегламентноеЗадание") Тогда
		Идентификатор = Идентификатор.УникальныйИдентификатор;
	КонецЕсли;
	
	Если ТипЗнч(Идентификатор) = Тип("Строка") Тогда
		ОбъектМетаданных = Метаданные.РегламентныеЗадания.Найти(Идентификатор);
		Если ОбъектМетаданных = Неопределено Тогда
			Идентификатор = Новый УникальныйИдентификатор(Идентификатор);
		Иначе
			Идентификатор = ОбъектМетаданных;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

// Аналог метода БСП. Удаляет непредопределенное регламентное задание (без учета очереди заданий модели сервиса).
//
// Параметры:
//  Идентификатор - ОбъектМетаданных - объект метаданных регламентного задания для поиска
//                                     непредопределенного регламентного задания.
//                - Строка - имя метаданных предопределенного регламентного задания
//                           или строка уникального идентификатора регламентного задания.
//                - УникальныйИдентификатор - идентификатор регламентного задания.
//                - РегламентноеЗадание - регламентное задание, уникальный идентификатор которого используется 
//                  для определения удаляемого экземпляра регламентного задания.
//
Процедура УдалитьРегламентноеЗадание(Знач Идентификатор) Экспорт
	
	Результат = ПереадресацияМодуляРегламентныеЗаданияСервер();
	Если Результат.МодульСуществует Тогда
		Результат.Модуль.УдалитьРегламентноеЗадание(Идентификатор);
		Возврат;
	КонецЕсли;
	
	Идентификатор = УточненныйИдентификаторЗадания(Идентификатор);
	
	СписокЗаданий = Новый Массив; // Массив из РегламентноеЗадание.
	
	Если ТипЗнч(Идентификатор) = Тип("ОбъектМетаданных") Тогда
		Отбор = Новый Структура("Метаданные, Предопределенное", Идентификатор, Ложь);
		СписокЗаданий = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Отбор);
	Иначе
		РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Идентификатор);
		Если РегламентноеЗадание <> Неопределено Тогда
			СписокЗаданий.Добавить(РегламентноеЗадание);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого РегламентноеЗадание Из СписокЗаданий Цикл
		ИдентификаторЗадания = УникальныйИдентификаторЗадания(РегламентноеЗадание);
		
		Если пбп_ОбщегоНазначенияВызовСервера.СуществуетБиблиотекаСтандартныхПодсистем() Тогда
			УдалитьРегламентноеЗаданиеСИспользованиемКэша(ИдентификаторЗадания);
		Иначе
			УдалитьРегламентноеЗаданиеБезКэша(ИдентификаторЗадания);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Аналог метода БСП.
//
Функция УникальныйИдентификаторЗадания(Знач Идентификатор, ВРазделенномРежимеИдентификаторЗаданияОчереди = Ложь)
	
	Если ТипЗнч(Идентификатор) = Тип("УникальныйИдентификатор") Тогда
		Возврат Идентификатор;
	КонецЕсли;
	
	Если ТипЗнч(Идентификатор) = Тип("РегламентноеЗадание") Тогда
		Возврат Идентификатор.УникальныйИдентификатор;
	КонецЕсли;
	
	Если ТипЗнч(Идентификатор) = Тип("Строка") Тогда
		Возврат Новый УникальныйИдентификатор(Идентификатор);
	КонецЕсли;
	
	Если ТипЗнч(Идентификатор) = Тип("ОбъектМетаданных") И Идентификатор.Предопределенное Тогда
		Возврат РегламентныеЗадания.НайтиПредопределенное(Идентификатор).УникальныйИдентификатор;
	ИначеЕсли ТипЗнч(Идентификатор) = Тип("ОбъектМетаданных") И НЕ Идентификатор.Предопределенное Тогда
		СписокЗаданий = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", Идентификатор));
		Для каждого РегламентноеЗадание Из СписокЗаданий Цикл
			Возврат РегламентноеЗадание.УникальныйИдентификатор;
		КонецЦикла; 
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область ОбщегоНазначения

#Область БезопасноеВыполнениеВнешнегоКода

// Аналог метода БСП. Проверяет, что переданное имя ИмяПроцедуры является именем экспортной процедуры конфигурации.
// Может использоваться для проверки, что переданная строка не содержит произвольного алгоритма
// на встроенном языке 1С:Предприятия перед использованием его в операторах Выполнить и Вычислить
// при их использовании для динамического вызова методов код конфигурации.
//
// В случае если переданная строка не является именем процедуры конфигурации, генерируется исключение.
//
// Предназначена для вызова из см. процедуру ВыполнитьМетодКонфигурации.
//
// Параметры:
//   ИмяПроцедуры - Строка - проверяемое имя экспортной процедуры.
//
Процедура ПроверитьИмяПроцедурыКонфигурации(Знач ИмяПроцедуры)
	
	ЧастиИмени = СтрРазделить(ИмяПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3.'"), 
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации");
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
				|Не существует общий модуль ""%4"".'"),
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ИмяОбъекта);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() = 3 Тогда
		ПолноеИмяОбъекта = ЧастиИмени[0] + "." + ЧастиИмени[1];
		Попытка
			Менеджер = МенеджерОбъектаПоИмени(ПолноеИмяОбъекта);
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
		Если Менеджер = Неопределено Тогда
			ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
				           |Не существует менеджер объекта ""%4"".'"),
				"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ПолноеИмяОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетодаОбъекта = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка того, что ИмяПроцедуры является допустимым идентификатором.
		// Например: МояПроцедура.
		ВременнаяСтруктура.Вставить(ИмяМетодаОбъекта);
	Исключение
		КодОсновногоЯзыка = Метаданные.ОсновнойЯзык.КодЯзыка;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", КодОсновногоЯзыка),
			УровеньЖурналаРегистрации.Ошибка, , , ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
			           |Имя метода ""%4"" не соответствует требованиям образования имен процедур и функций.'"),
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ИмяМетодаОбъекта);
	КонецПопытки;
	
КонецПроцедуры

// Аналог метода БСП. Возвращает менеджер объекта по имени.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Имя - Строка - имя например, "Справочник", "Справочники", "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникиМенеджер
//  СправочникМенеджер
//  ДокументыМенеджер
//  ДокументМенеджер
//  ...
//
Функция МенеджерОбъектаПоИмени(Имя)
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	
	Если ЧастиИмени.Количество() > 0 Тогда
		КлассОМ = ВРег(ЧастиИмени[0]);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяОМ = ЧастиИмени[1];
	КонецЕсли;
	
	Если      КлассОМ = "ПЛАНОБМЕНА"
	 Или      КлассОМ = "ПЛАНЫОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли КлассОМ = "СПРАВОЧНИК"
	      Или КлассОМ = "СПРАВОЧНИКИ" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли КлассОМ = "ДОКУМЕНТ"
	      Или КлассОМ = "ДОКУМЕНТЫ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли КлассОМ = "ЖУРНАЛДОКУМЕНТОВ"
	      Или КлассОМ = "ЖУРНАЛЫДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли КлассОМ = "ПЕРЕЧИСЛЕНИЕ"
	      Или КлассОМ = "ПЕРЕЧИСЛЕНИЯ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли КлассОМ = "ОБЩИЙМОДУЛЬ"
	      Или КлассОМ = "ОБЩИЕМОДУЛИ" Тогда
		
		Возврат ОбщийМодуль(ИмяОМ);
		
	ИначеЕсли КлассОМ = "ОТЧЕТ"
	      Или КлассОМ = "ОТЧЕТЫ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли КлассОМ = "ОБРАБОТКА"
	      Или КлассОМ = "ОБРАБОТКИ" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВХАРАКТЕРИСТИК"
	      Или КлассОМ = "ПЛАНЫВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли КлассОМ = "ПЛАНСЧЕТОВ"
	      Или КлассОМ = "ПЛАНЫСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВРАСЧЕТА"
	      Или КлассОМ = "ПЛАНЫВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли КлассОМ = "РЕГИСТРСВЕДЕНИЙ"
	      Или КлассОМ = "РЕГИСТРЫСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли КлассОМ = "РЕГИСТРНАКОПЛЕНИЯ"
	      Или КлассОМ = "РЕГИСТРЫНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли КлассОМ = "РЕГИСТРБУХГАЛТЕРИИ"
	      Или КлассОМ = "РЕГИСТРЫБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли КлассОМ = "РЕГИСТРРАСЧЕТА"
	      Или КлассОМ = "РЕГИСТРЫРАСЧЕТА" Тогда
		
		Если ЧастиИмени.Количество() < 3 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ВРег(ЧастиИмени[2]);
			Если ЧастиИмени.Количество() > 3 Тогда
				ИмяПодчиненногоОМ = ЧастиИмени[3];
			КонецЕсли;
			Если КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТ"
			 Или КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТЫ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОМ = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли КлассОМ = "БИЗНЕСПРОЦЕСС"
	      Или КлассОМ = "БИЗНЕСПРОЦЕССЫ" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли КлассОМ = "ЗАДАЧА"
	      Или КлассОМ = "ЗАДАЧИ" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли КлассОМ = "КОНСТАНТА"
	      Или КлассОМ = "КОНСТАНТЫ" Тогда
		Менеджер = Константы;
		
	ИначеЕсли КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТЬ"
	      Или КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТИ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Если ЗначениеЗаполнено(ИмяОМ) Тогда
			Попытка
				Возврат Менеджер[ИмяОМ];
			Исключение
				Менеджер = Неопределено;
			КонецПопытки;
		Иначе
			Возврат Менеджер;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось получить менеджер для объекта ""%1""'"), Имя);
	
КонецФункции

#КонецОбласти

#Область УсловныеВызовы

// Аналог метода БСП. Возвращает серверный модуль менеджера по имени объекта.
//
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не существует.'"), Имя);
	КонецЕсли;
	
	// BSLLS:ExecuteExternalCodeInCommonModule-off
	// ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
	УстановитьБезопасныйРежим(Истина);
	Модуль = Вычислить(Имя);
	// BSLLS:ExecuteExternalCodeInCommonModule-on
	
	Возврат Модуль;
КонецФункции

#КонецОбласти

#Область ХранилищеНастроек

// Аналог метода БСП.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения)
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Настройки,
		ОписаниеНастроек, ИмяПользователя);
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Аналог метода БСП.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
			ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек),
			ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
		
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Аналог метода БСП.
//
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

// Аналог метода БСП. Возвращает строку ключа настроек, не превышающую допустимую длину 128 символов.
// Если указанная строка превышает 128, тогда вместо символов сверх 96 символов
// добавляется их хеш-сумма по алгоритму MD5 размером 32 символа.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
// Возвращаемое значение:
//  Строка - не более 128 символов.
//
Функция КлючНастроек(Знач Строка)
	Возврат СократитьСтрокуКонтрольнойСуммой(Строка, 128);
КонецФункции

#КонецОбласти

#Область Метаданные

// Аналог метода БСП.
//
// Параметры:
//  ПолноеИмя - Строка - Полное имя объекта метаданных.
//
Процедура ПроверитьОбъектМетаданныхСуществует(ПолноеИмя)
	
	Если ОбъектМетаданныхПоПолномуИмени(ПолноеИмя) = Неопределено Тогда 
		ВызватьИсключение пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неизвестный тип объекта метаданных ""%1"".';
				|en = 'Unknown metadata object type: ""%1"".'"), ПолноеИмя);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область Прочее

Процедура УдалитьРегламентноеЗаданиеСИспользованиемКэша(ИдентификаторЗадания)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
	ЭлементБлокировки.УстановитьЗначение("Идентификатор", Строка(ИдентификаторЗадания));
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Задание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторЗадания);
		Если Задание <> Неопределено Тогда
			Задание.Удалить();
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Процедура УдалитьРегламентноеЗаданиеБезКэша(ИдентификаторЗадания)
	
	Попытка
		Задание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторЗадания);
		Если Задание <> Неопределено Тогда
			Задание.Удалить();
		КонецЕсли;
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти