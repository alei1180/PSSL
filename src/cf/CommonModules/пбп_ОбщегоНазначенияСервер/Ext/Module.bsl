// Библиотека проектных подсистем для упрощения разработки архитектуры на 1С: Предприятие 8,
// включая доработку типовых конфигураций.
//
// Copyright First BIT company
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
// URL:    https://github.com/firstBitSportivnaya/PSSL/
//

////////////////////////////////////////////////////////////////////////////////
// Общего назначения (сервер): для серверных функций общего назначения

#Область ПрограммныйИнтерфейс

// Возвращает имя информационной базы.
// 
// Возвращаемое значение:
//   - Строка - Имя информационной базы.
//
Функция ПолучитьИмяИнформационнойБазы() Экспорт
	
	СтрокаПодключения = СтрокаСоединенияИнформационнойБазы();
	
	НомерСимвола = СтрНайти(СтрокаПодключения, "File=");
	Если НомерСимвола > 0 Тогда
		
		// Это Файловая база.
		СтрокаСправа = Сред(СтрокаПодключения, НомерСимвола + 6);
		
		Возврат Сред(СтрокаСправа, 1, СтрДлина(СтрокаСправа) - 2);
	КонецЕсли;
	
	НомерСимвола = СтрНайти(СтрокаПодключения, "Ref=");
	Если НомерСимвола > 0 Тогда
		
		// Это серверная база.
		СтрокаСправа = Сред(СтрокаПодключения, НомерСимвола + 5);
		
		Возврат Сред(СтрокаСправа, 1, СтрДлина(СтрокаСправа) - 2);
	КонецЕсли;
	
	Возврат "";
	
Конецфункции

// Возвращает значение предопределенного элемента ПВХ по идентификатору.
//
// Параметры:
//  Идентификатор - Строка - Идентификатор переменной ПВХ.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - ПроизвольныйТип - Значение переменной ПВХ.
//  - Массив - Массив значений переменной ПВХ.
// 
Функция ПолучитьПредопределенноеЗначение(Идентификатор, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат пбп_ОбщегоНазначенияПовтИсп.ПолучитьПредопределенноеЗначение(Идентификатор);
	Иначе
		Возврат ПланыВидовХарактеристик.пбп_ПредопределенныеЗначения.ПолучитьЗначение(Идентификатор);
	КонецЕсли;
	
КонецФункции

// Возвращает соответствие предопределенных элементов ПВХ по имени.
//
// Параметры:
//  Идентификаторы - Строка - Идентификаторы переменных ПВХ, перечисленные через запятую.
//  ВРазрезеКлючей - Булево - Признак получения данных в виде соответствия, где Ключ - Идентификатор переменной.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - Соответствие - Соответствие идентификаторов и значений переменных ПВХ.
//  - Массив - Массив значений переменных ПВХ.
//
Функция ПолучитьПредопределенныеЗначения(Идентификаторы, ВРазрезеКлючей = Ложь, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат пбп_ОбщегоНазначенияПовтИсп.ПолучитьПредопределенныеЗначения(Идентификаторы, ВРазрезеКлючей);
	Иначе
		Возврат ПланыВидовХарактеристик.пбп_ПредопределенныеЗначения.ПолучитьЗначения(Идентификаторы, ВРазрезеКлючей);
	КонецЕсли;
	
КонецФункции

// Возвращает массив структур соответствий по отбору
//
// Параметры:
//  ИдентификаторНастройки - Строка - Идентификатор элемента справочника "Тип соответствия объектов ИБ".
//  Объект1 - ПроизвольныйТип - Объект1.
//  Объект2 - ПроизвольныйТип - Объект2.
//  Объект3 - ПроизвольныйТип - Объект3.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - Массив - соответствие объектов ИБ в виде структур.
//
Функция ПолучитьСоответствиеОбъектовИБ(ИдентификаторНастройки, Объект1 = Неопределено, Объект2 = Неопределено, Объект3 = Неопределено, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат пбп_ОбщегоНазначенияПовтИсп.ПолучитьСоответствиеОбъектовИБ(ИдентификаторНастройки, Объект1, Объект2, Объект3);
	Иначе
		Возврат РегистрыСведений.пбп_СоответствияОбъектовИБ.ПолучитьСоответствиеОбъектовИБ(
			ИдентификаторНастройки,
			Объект1,
			Объект2,
			Объект3);
	КонецЕсли;
	
КонецФункции

// Возвращает таблицу значений с датами за период
//
// Параметры:
//  НачалоПериода	 - Дата - Начало периода.
//  ОкончаниеПериода - Дата - Конец периода.
//  Интервал		 - Строка - одно из следующих значений:
//             (Секунда, Минута, Час, День, Неделя, Месяц, Квартал, Полугодие, Год)
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица значений с датами за период. Содержит одну колонку "Период".
//
Функция ПолучитьТаблицуДатЗаПериод(НачалоПериода, ОкончаниеПериода, Интервал = "День") Экспорт
	
	ТаблицаИнтервалов = Новый ТаблицаЗначений;
	ТаблицаИнтервалов.Колонки.Добавить("Период", Новый ОписаниеТипов("Дата"));
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
		|	НАЧАЛОПЕРИОДА(&НачалоПериода, ДЕНЬ) КАК Период
		|
		|УПОРЯДОЧИТЬ ПО
		|	Период
		|ИТОГИ ПО
		|	Период ПЕРИОДАМИ(%Интервал%, &НачалоПериода, &ОкончаниеПериода)";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%Интервал%", Интервал);
	
	Запрос.УстановитьПараметр("НачалоПериода", НачалоПериода);
	Запрос.УстановитьПараметр("ОкончаниеПериода", ОкончаниеПериода);
	
	Выборка = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Период", "ВСЕ");
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаИнтервалов.Добавить(), Выборка);
	КонецЦикла;
	
	Возврат ТаблицаИнтервалов;
	
КонецФункции

//Устанавливает элемент отбор динамического списка
//
//Параметры:
//Список			- обрабатываемый динамический список,
//ИмяПоля			- имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения		- вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение 	- значение отбора
//
Процедура УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено, Представление = "") Экспорт
	
	ЭлементОтбора = Список.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.ЛевоеЗначение		= Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения		= ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
	ЭлементОтбора.Использование		= Истина;
	ЭлементОтбора.ПравоеЗначение	= ПравоеЗначение;
	ЭлементОтбора.Представление		= Представление;
	
КонецПроцедуры

//Изменяет элемент отбора динамического списка
//
//Параметры:
//Список         - обрабатываемый динамический список,
//ИмяПоля        - имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения   - вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение - значение отбора,
//Установить     - признак необходимости установить отбор
//
Процедура ИзменитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено) Экспорт
	
	УдалитьЭлементОтбораСписка(Список, ИмяПоля);
	
	Если Установить Тогда
		
		УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения);
		
	КонецЕсли;
	
КонецПроцедуры

//Удаляет элемент отбора динамического списка
//
//Параметры:
//Список  - обрабатываемый динамический список,
//ИмяПоля - имя поля компоновки, отбор по которому нужно удалить
//
Процедура УдалитьЭлементОтбораСписка(Список, ИмяПоля) Экспорт
	
	ЭлементыДляУдаления = Новый Массив;
	
	ЭлементыОтбора = Список.Отбор.Элементы;
	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных")
			И ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки Тогда
			ЭлементыДляУдаления.Добавить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементОтбораДляУдаления Из ЭлементыДляУдаления Цикл
		
		ЭлементыОтбора.Удалить(ЭлементОтбораДляУдаления);
		
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает полный текст ошибки возникающей при исключении
//
// Параметры:
//	ЗаголовокОшибки - Строка - описание действия повлекшего ошибку
//	ТекстИсключения - Строка - подробное представление ошибки
//	ДополнительныеСообщения - Массив - массив дополнительных сообщений
Функция ПолучениеПолногоТекстаОшибкиПриИсключении(ЗаголовокОшибки, ТекстИсключения, ДополнительныеСообщения) Экспорт

	ТекстОшибки = ЗаголовокОшибки;
	Для Каждого Сообщение Из ДополнительныеСообщения Цикл
		ТекстОшибки = ТекстОшибки + Символы.ПС + Сообщение.Текст;
	КонецЦикла;
	ТекстОшибки = ТекстОшибки + Символы.ПС + ТекстИсключения;
	
	Возврат ТекстОшибки;

КонецФункции

// Процедура удаляет экземпляр регламентного задания.
// 
// Параметры:
//  КлючЗадания - Строка - Ключ регламентного задания
//
Процедура УдалитьЭкземплярРегламентногоЗадания(КлючЗадания) Экспорт
	
	ОтборЗадания = Новый Структура;
	ОтборЗадания.Вставить("Ключ", КлючЗадания);
	МассивРегламентныхЗаданий = пбп_Переадресация.НайтиЗадания(ОтборЗадания);
	
	Если МассивРегламентныхЗаданий.Количество() Тогда
		РегламентноеЗадание = МассивРегламентныхЗаданий[0];
		пбп_Переадресация.УдалитьЗадание(РегламентноеЗадание.УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись элемента справочника.
// 
// Параметры:
//  ТекущийОбъект  - СправочникОбъект - Записываемый объект.
//  Заголовок      - Строка (По умолчанию = "").
//  РежимСообщений - Строка: "Нет","Все","Ошибки" (По умолчанию = "Все").
//  РежимЗагрузки  - Булево (По умолчанию = Ложь).
// 
// Возвращаемое значение:
//   Булево - Справочник записан.
// 
Функция ЗаписатьСправочник(ТекущийОбъект, Заголовок = "", РежимСообщений = "Все", РежимЗагрузки = Ложь) Экспорт
	
	СправочникЗаписан = Ложь;
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		Если РежимЗагрузки Тогда
			ТекущийОбъект.ОбменДанными.Загрузка = Истина;
			СправочникЗаписан = Истина;
		Иначе
			СправочникЗаписан = ТекущийОбъект.ПроверитьЗаполнение();
		КонецЕсли;
		
		Если СправочникЗаписан Тогда
			
			ТекущийОбъект.Записать();
			Если РежимыВывода.ВыводитьИнформацию Тогда
				пбп_Переадресация.СообщитьПользователю(
					СтрШаблон(НСтр("ru='Записан справочник ""%1"".';en='Directory ""%1"" saved.'"), ТекущийОбъект.Ссылка));
			КонецЕсли;
		КонецЕсли;
	Исключение
		
		СправочникЗаписан = Ложь;
		
		Если РежимыВывода.ВыводитьОшибки Тогда
			пбп_Переадресация.СообщитьПользователю(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации("пбп_.ОшибкаЗаписиСправочника", УровеньЖурналаРегистрации.Ошибка,,,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат СправочникЗаписан;
	
КонецФункции // ЗаписатьСправочник()

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
// 
// Параметры:
//  ТекстXML - Текст в формате XML.
//      Схема XML:
// 			<?xml version="1.0" encoding="utf-8"?>
// 			<xs:schema attributeFormDefault="unqualified" 
// 						elementFormDefault="qualified" xmlns:xs="http:// www.w3.org/2001/XMLSchema">
//			  <xs:element name="Items">
//			 	<xs:complexType>
// 				  <xs:sequence>
// 					<xs:element maxOccurs="unbounded" name="Item">
// 					  <xs:complexType>
// 						<xs:attribute name="Code" type="xs:integer" use="required" />
// 						<xs:attribute name="Name" type="xs:string" use="required" />
// 						<xs:attribute name="Socr" type="xs:string" use="required" />
// 						<xs:attribute name="Index" type="xs:string" use="required" />
// 					  </xs:complexType>
// 					</xs:element>
// 				  </xs:sequence>
// 				  <xs:attribute name="Description" type="xs:string" use="required" />
// 				  <xs:attribute name="Columns" type="xs:string" use="required" />
// 				</xs:complexType>
// 			 </xs:element>
//			 </xs:schema> 
//      Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение(НСтр("ru='Ошибка в структуре XML';en='Ошибка в структуре XML'"));
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение(НСтр("ru='Ошибка в структуре XML';en='Ошибка в структуре XML'"));
		КонецЕсли;
		
		НоваяСтрока = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			НоваяСтрока[Сч - 1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
	КонецЦикла;
	
	Результат = Новый Структура("ИмяТаблицы, Данные", ИмяТаблицы, ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Определяет режимы вывода сообщений.
// 
// Параметры:
//  РежимСообщений - Строка - "Нет", "Все", "Ошибки".
// 
// Возвращаемое значение:
//  Структура - Структура режима вывода сообщений.
//
Функция ОпределитьРежимыВывода(РежимСообщений) Экспорт
	
	РежимыВывода = Новый Структура("ВыводитьОшибки, ВыводитьИнформацию",
		ВРег(РежимСообщений) = ВРег("Все") Или ВРег(РежимСообщений) = ВРег("Ошибки"),
		ВРег(РежимСообщений) = ВРег("Все"));
	
	Возврат РежимыВывода;
	
КонецФункции // ОпределитьРежимВывода()

// Добавляет новую строку "ДобавляемаяСтрока" к тексту "Текст".
// 
// Параметры:
//  Текст             - Строка - Текущий текст.
//  ДобавляемаяСтрока - Строка - Добавляемая строка.
//
Процедура ДобавитьСтрокуКТексту(Текст, ДобавляемаяСтрока) Экспорт
	
	Текст = СтрШаблон("%1%2%3", Текст, ?(СокрЛП(Текст) = "", "", Символы.ПС), ДобавляемаяСтрока);
	
КонецПроцедуры // ДобавитьСтрокуКТексту()

// По массиву типов создается список выбора для быстрого выбора составного типа.
// 
// Параметры:
//  МассивТипов - Массив - Массив типов.
// 
// Возвращаемое значение:
//  СписокЗначений - Список выбора.
//
Функция ПодготовитьСписокВыбораТипа(МассивТипов) Экспорт
	
	СписокВыбора = Новый СписокЗначений;
	Для Каждого ТекущийТип Из МассивТипов Цикл
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТекущийТип);
		Если ОбъектМетаданных = Неопределено Тогда
			ТекПредставление = Строка(ТекущийТип);
		Иначе
			ТекПредставление = ОбъектМетаданных.Синоним;
		КонецЕсли;
		
		СписокВыбора.Добавить(ТекущийТип,ТекПредставление);
	КонецЦикла;
	
	Возврат СписокВыбора;
	
КонецФункции // ПодготовитьСписокВыбораТипа()

// Функция определяет имя объекта ссылочного типа по описанию типов.
// 
// Параметры:
//  ОписаниеТипов   - ОписаниеТипов - содержит тип, имя объекта которого нужно определить.
//  ИмяКоллекции    - Строка - имя коллекции объектов метаданных: "Справочники","Документы" и т.п.
//  НачалоИмениТипа - Строка - начало строкового представления типа : "СправочникСсылка", "ДокументСсылка" и т.п.
//
// Возвращаемое значение:
//  РезСтруктура   - Структура (Ключи: "Имя","Синоним","ИмяТипа"; Значения: Строка) 
//                   Неопределено (если имя не удалось определить). 
//
Функция ПолучитьИмяОбъектаПоОписаниюТипов(ОписаниеТипов, ИмяКоллекции, НачалоИмениТипа) Экспорт
	
	Результат = Неопределено;
	
	Для Каждого ТекущийОбъект Из Метаданные[ИмяКоллекции] Цикл
		
		ИмяТипа = СтрШаблон("%1.%2", НачалоИмениТипа, ТекущийОбъект.Имя);
		Если ОписаниеТипов.СодержитТип(Тип(ИмяТипа)) Тогда
			
			Результат = Новый Структура;
			Результат.Вставить("Имя", ТекущийОбъект.Имя);
			Результат.Вставить("Синоним", ТекущийОбъект.Синоним);
			Результат.Вставить("ИмяТипа", ИмяТипа);
			
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ПолучитьИмяОбъектаПоОписаниюТипов()

// Функция получает имя объекта по имени формы.
// 
// Параметры:
//  ИмяФормы - Строка - Имя формы.
//  
// Возвращаемое значение:
//   Строка - Имя объекта.
// 
Функция ПолучитьИмяОбъектаПоИмениФормы(ИмяФормы, ПолноеИмя = Истина) Экспорт
	
	МассивИмениФормы = пбп_СтроковыеФункцииКлиентСервер.РазобратьСтрокуСРазделителями(ИмяФормы, ".");
	Результат = СтрШаблон("%1%2",
		?(ПолноеИмя, СтрШаблон("%1.", МассивИмениФормы.Получить(0)), ""),
		МассивИмениФормы.Получить(1));
		
	Возврат Результат;
	
КонецФункции // ПолучитьИмяОбъектаПоИмениФормы()

// Функция получает значение константы по ее имени.
// 
// Параметры:
//  ИмяКонстанты - Строка - Имя константы в метаданных.
//  
// Возвращаемое значение:
//   Строка - Значение константы.
// 
Функция ПолучитьЗначениеКонстанты(ИмяКонстанты) Экспорт
	
	Возврат Константы[ИмяКонстанты].Получить();
	
КонецФункции

#Область ОтладкаВременныхТаблиц

// Функция возвращает все поля указанной временной таблицы из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
//
// Параметры:
//  ЗапросМенеджер - Запрос, МенеджерВременныхТаблиц - запрос (для вычленения текста запроса) или менеджер.
//  ИмяВременнойТаблицы - Строка - Имя временной таблицы
// 
// Возвращаемое значение:
//  - ТаблицаЗначений - Результат временной таблицы запроса.
//
// Пример вызова функции:
//    ЗапасыСервер.ПоказатьВременнуюТаблицу(МенеджерВременныхТаблиц, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(ЗапросМенеджер, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(ЗапросМенеджер) = Тип("Запрос") Тогда
		Если ЗапросМенеджер.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			ЗапросМенеджер.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Иначе
			МенеджерВременныхТаблиц = ЗапросМенеджер.МенеджерВременныхТаблиц;
		КонецЕсли;
		
		ЗапросМенеджер.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = ЗапросМенеджер;
	КонецЕсли;
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		ЗапросМенеджер.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли;
	
	Возврат ДанныеТаблицы;
	
КонецФункции

// Функция возвращает результат запроса.
//
// Параметры:
//  ТекстЗапроса - Строка - текст исполняемого запроса.
//  ПараметрыЗапроса - Соответствие - Соответствие параметров запроса.
//  МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - Менеджер временных таблиц запроса.
// 
// Возвращаемое значение:
//  - ТаблицаЗначений - Результат выполнения запроса.
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено,
	МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Формирует список полей временных таблиц.
//
// Параметры:
//  ЗапросМенеджер - Запрос, МенеджерВременныхТаблиц - запрос (для вычленения текста запроса) или менеджер 
//		временных таблиц (имена временных таблиц в этом случае надо передавать явно).
//  ИменаВременныхТаблиц	- Строка - строка с именами интересующих временных таблиц (обязательный параметр при передаче 
//		менеджера ВТ вместо запроса в первом параметре).
// 
// Возвращаемое значение:
//  Массив - Поля временных таблицы, находящиеся в менеджере или запросе.
//
// Пример вызова функции:
//      ПросмотрВременныхТаблиц(Запрос, "")
//
Функция ПоляВременныхТаблиц(ЗапросМенеджер, ИменаВременныхТаблиц = "") Экспорт
	
	// Предварительная обработка параметров:
	Если ТипЗнч(ЗапросМенеджер) = Тип("МенеджерВременныхТаблиц") Тогда
		Если ИменаВременныхТаблиц = "" Тогда
			Возврат "Укажите имена временных таблиц через запятую";
		Иначе
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ЗапросМенеджер;
		КонецЕсли;
	Иначе
		Запрос = ЗапросМенеджер;
	КонецЕсли;
	
	ТекстЗапроса = ВРег(Запрос.Текст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.Таб, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.ВТаб, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.НПП, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ")", ") ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "(", " (");
	
	ОчищенныйТекстЗапроса = "";
	Для НомерСтроки = 1 По СтрЧислоСтрок(ТекстЗапроса) Цикл
		
		ОчереднаяСтрока = СтрПолучитьСтроку(ТекстЗапроса, НомерСтроки);
		ПозицияКомментария = СтрНайти(ОчереднаяСтрока, "//");
		
		Если ПозицияКомментария > 0 Тогда
			ОчереднаяСтрока = Лев(ОчереднаяСтрока,ПозицияКомментария-1);
		КонецЕсли;
		
		ОчищенныйТекстЗапроса = ОчищенныйТекстЗапроса + " " + ОчереднаяСтрока;
	КонецЦикла;
	
	ТекстЗапроса = ОчищенныйТекстЗапроса;
	
	// Парсинг текста запроса и получение из него имен временных таблиц	
	ВременныеТаблицыЗапроса = новый Массив;
	
	Если НЕ ИменаВременныхТаблиц = "" Тогда
		
		СписокДополнительныхИмен = СтрЗаменить(ИменаВременныхТаблиц, ",", Символы.ПС);
		Для Счетчик = 1 По СтрЧислоСтрок(СписокДополнительныхИмен) Цикл
			ТекСтрока = СтрПолучитьСтроку(СписокДополнительныхИмен, Счетчик);
			ВременныеТаблицыЗапроса.Добавить(ТекСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "ПОМЕСТИТЬ");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "ИЗ", "КАК");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "СОЕДИНЕНИЕ", "КАК");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	УничтожаемыеВременныеТаблицы = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "УНИЧТОЖИТЬ");
	Для Каждого КлючЗначение Из УничтожаемыеВременныеТаблицы Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	Ответ = Новый Структура;
	
	Если Запрос.МенеджерВременныхТаблиц = Неопределено тогда
		
		// На случай, если ВТ удаляются в тексте запроса, сложнейший алгоритм предварительно скопирует их
		Смещение = 0;
		Если УничтожаемыеВременныеТаблицы.Количество() Тогда
			Для Каждого КлючИЗначение Из УничтожаемыеВременныеТаблицы Цикл
				
				ПозицияУничтожения = КлючИЗначение.Значение + Смещение;
				ИмяВТ = КлючИЗначение.Ключ ;
				НовыйПодзапросКопирования   = "ВЫБРАТЬ * ПОМЕСТИТЬ КОПИЯ" + ИмяВТ + " ИЗ "+ ИмяВТ + ";";
				
				ТекстЗапроса = Лев(ТекстЗапроса, ПозицияУничтожения - 1) + НовыйПодзапросКопирования + Прав(
					ТекстЗапроса, СтрДлина(ТекстЗапроса) - (ПозицияУничтожения - 1));
					
				Смещение = Смещение + НовыйПодзапросКопирования;
			КонецЦикла;
		КонецЕсли;
		
		// Выполняем запрос для создания интересующих нас таблиц
		ЗапросТМП = Новый Запрос;
		ЗапросТМП.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
		Для Каждого Параметр Из Запрос.Параметры Цикл
			ЗапросТМП.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
		
		ЗапросТМП.Текст = ТекстЗапроса;
		ЗапросТМП.Выполнить();
		
		ЗаполнитьТаблицыПоСпискуИмен(Ответ, ВременныеТаблицыЗапроса, ЗапросТМП.МенеджерВременныхТаблиц);
		
		ЗапросТМП.МенеджерВременныхТаблиц.Закрыть();
		
	Иначе
		
		// Это надо запускать после выполнения запроса, чтобы временные таблицы уже были созданы	
		ОтсутствующиеИменаТаблиц = ЗаполнитьТаблицыПоСпискуИмен(
			Ответ, ВременныеТаблицыЗапроса, Запрос.МенеджерВременныхТаблиц);
		
		Для Каждого ИмяТаблицы Из ОтсутствующиеИменаТаблиц Цикл
			
			Если УничтожаемыеВременныеТаблицы.Получить(ИмяТаблицы) = Неопределено Тогда
				СообщениеОбОшибке = "Таблица еще не создана либо имя задано не верно";
			Иначе
				СообщениеОбОшибке = "Таблица уничтожается при выполнении пакета";
			КонецЕсли;
			
			Ответ.Вставить(ИмяТаблицы, СообщениеОбОшибке);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти // ОтладкаВременныхТаблиц

// Возвращает массив значений произвольного типа, объекта соответствия.
//
// Параметры:
//  ИдентификаторНастройки - Строка - Идентификатор элемента справочника "Тип соответствия объектов ИБ".
//  ИмяКлюча		 - Строка - поле регистра сведений пбп_СоответствияОбъектовИБ, по которому устанавливается отбор. 
//  ЗначениеКлюча	 - ПроизвольныйТип - Значение ключа по которому установлен отбор.
//  ИмяОбъекта		 - Строка - получаемое поле регистра сведений пбп_СоответствияОбъектовИБ.
//  ИспользоватьКэш	 - Булево - Признак получения данных из кэша. 
// 
// Возвращаемое значение:
//   - Массив - Значения объекта из регистра сведений пбп_СоответствияОбъектовИБ, 
//				если соответствие одно в массив будет один элемент 
//
Функция ПолучитьЗначенияОбъектаСоответствияПоКлючу(ИдентификаторНастройки, ИмяКлюча, ЗначениеКлюча, ИмяОбъекта, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат пбп_ОбщегоНазначенияПовтИсп.ПолучитьЗначенияОбъектаСоответствияПоКлючу(
			ИдентификаторНастройки, 
			ИмяКлюча, 
			ЗначениеКлюча, 
			ИмяОбъекта);
	Иначе
		Возврат РегистрыСведений.пбп_СоответствияОбъектовИБ.ПолучитьЗначенияОбъектаСоответствияПоКлючу(
			ИдентификаторНастройки, 
			ИмяКлюча, 
			ЗначениеКлюча, 
			ИмяОбъекта);
	КонецЕсли;
	
КонецФункции

// Возвращает Истину или Ложь, существует ли "Библиотеки стандартных подсистем" (БСП),
// встроенная в конфигурацию.
//
// Возвращаемое значение:
//  Булево - Истина, если БСП существует.
//
Функция СуществуетБиблиотекаСтандартныхПодсистем() Экспорт
	
	ВерсияБСП = Неопределено;
	// Точка входа, где можно попытаться проверить подключена ли БСП
	Если Метаданные.ОбщиеМодули.Найти("СтандартныеПодсистемыСервер") <> Неопределено Тогда
		Попытка
			УстановитьБезопасныйРежим(Истина);
			МодульБСП = ОбщийМодуль("СтандартныеПодсистемыСервер");
			ВерсияБСП = МодульБСП.ВерсияБиблиотеки();
		Исключение
			ВерсияБСП = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ВерсияБСП <> Неопределено;
	
КонецФункции

#Область ПользовательскиеФункции

// Выполняет пользовательскую функцию с переданными параметрами.
//
// Параметры:
//  Ссылка		 - СправочникСсылка.пбп_ПользовательскиеФункции - Ссылка пользовательской функции,
//      которую требуется выполнить
//  Параметры	 - Структура - Подготовленные параметры для выполнения пользовательской функции
//   * Ключ - Строка - Имя параметра
//   * Значение - Структура - Значение параметра
// 
// Возвращаемое значение:
//  Неопределено, в - случае успешного выполнения, Описание ошибки, в случае неудачи.
//
Функция ВыполнитьПользовательскуюФункциюСПараметрами(Ссылка, Параметры) Экспорт
	
	Отказ = Ложь;
	Результат = Неопределено;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	пбп_ПользовательскиеФункции.КодПодпрограммы КАК КодПодпрограммы
		|ИЗ
		|	Справочник.пбп_ПользовательскиеФункции КАК пбп_ПользовательскиеФункции
		|ГДЕ
		|	пбп_ПользовательскиеФункции.Ссылка = &Ссылка
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	пбп_ПользовательскиеФункцииПараметрыФункции.Наименование КАК Наименование,
		|	пбп_ПользовательскиеФункцииПараметрыФункции.Тип КАК Тип,
		|	пбп_ПользовательскиеФункцииПараметрыФункции.Необязательный КАК Необязательный
		|ИЗ
		|	Справочник.пбп_ПользовательскиеФункции.ПараметрыФункции КАК пбп_ПользовательскиеФункцииПараметрыФункции
		|ГДЕ
		|	пбп_ПользовательскиеФункцииПараметрыФункции.Ссылка = &Ссылка
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	пбп_ПользовательскиеФункцииПеременные.Имя КАК Имя,
		|	пбп_ПользовательскиеФункцииПеременные.Значение КАК Значение
		|ИЗ
		|	Справочник.пбп_ПользовательскиеФункции.Переменные КАК пбп_ПользовательскиеФункцииПеременные
		|ГДЕ
		|	пбп_ПользовательскиеФункцииПеременные.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатыЗапроса[0].Выбрать();
	ВыборкаТЧ = РезультатыЗапроса[1].Выбрать();
	ВыборкаПерем = РезультатыЗапроса[2].Выбрать();
	
	Выборка.Следующий();
	ТекстФункции = Выборка.КодПодпрограммы;
	
	Переменные = Новый Структура;
	Пока ВыборкаПерем.Следующий() Цикл
		Если ПустаяСтрока(ВыборкаПерем.Имя) И Переменные.Свойство(ВыборкаПерем.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Переменные.Вставить(ВыборкаПерем.Имя, ВыборкаПерем.Значение);
		ЗаменаПодстроки(ТекстФункции, ВыборкаПерем.Имя, "Переменные.");
	КонецЦикла;
	
	Параметры = ПодставитьПараметрыВФункцию(ТекстФункции, Параметры, ВыборкаТЧ, Отказ);
	
	Если Отказ Тогда
		ВызватьИсключение(НСтр("ru='Ошибки при подстановке параметров!.'"));
	КонецЕсли;
	
	Попытка
		Выполнить(ТекстФункции);
	Исключение
		ВызватьИсключение КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

// Выполняет действия при записи предопределенного элемента.
//
// Параметры:
//  Объект - СправочникОбъект, ПланВидовХарактеристикОбъект - предопределенный элемент
//                             из подсистемы предопределенных элементов
//
Процедура ОбработатьСуществующийПредопределенныйЭлемент(Объект) Экспорт
	
	пбп_ПредопределенныеЗначения.ОбновитьХешПредопределенногоЭлемента(Объект);
	
КонецПроцедуры

#Область УсловныеВызовы

// Возвращает ссылку на общий модуль или модуль менеджера по имени.
// Применяется для условного вызова процедуры или функции совместно с ОбщегоНазначения.ПодсистемаСуществует.
// См. также ОбщегоНазначенияКлиент.ОбщийМодуль для вызова клиентского кода.
//
// Параметры:
//  Имя - Строка - имя общего модуля или модуля менеджера, например "ОбновлениеКонфигурации", 
//                 "Обработка.ПолнотекстовыйПоиск".
//
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
//
// Пример:
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбновлениеКонфигурации") Тогда
//		МодульОбновлениеКонфигурации = ОбщегоНазначения.ОбщийМодуль("ОбновлениеКонфигурации");
//		МодульОбновлениеКонфигурации.<Имя процедуры>();
//	КонецЕсли;
//
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
//		МодульОбработкаПолнотекстовыйПоиск = ОбщегоНазначения.ОбщийМодуль("Обработка.ПолнотекстовыйПоиск");
//		МодульОбработкаПолнотекстовыйПоиск.<Имя процедуры>();
//	КонецЕсли;
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		// BSLLS:ExecuteExternalCodeInCommonModule-off
		// ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
		УстановитьБезопасныйРежим(Истина);
		Модуль = Вычислить(Имя);
		// BSLLS:ExecuteExternalCodeInCommonModule-on
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение(пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра %1 в %2. Общий модуль ""%1"" не существует.'"), 
			"Имя", "пбп_ОбщегоНазначенияСервер.ОбщийМодуль", Имя), 
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

#КонецОбласти

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Функция ЗаполнитьТаблицыПоСпискуИмен(СтруктураОтвета, МассивИменТаблиц, Менеджер)
	
	ОтсутствующиеИменаТаблиц = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	
	Для Каждого ИмяТаблицы Из МассивИменТаблиц Цикл
		Если НЕ СтруктураОтвета.Свойство(ИмяТаблицы) Тогда
			
			Запрос.Текст = "ВЫБРАТЬ * ИЗ " + ИмяТаблицы + " КАК " + ИмяТаблицы;
			Попытка
				СтруктураОтвета.Вставить(ИмяТаблицы, Запрос.Выполнить().Выгрузить());
			Исключение
				СтруктураОтвета.Вставить(ИмяТаблицы, ОписаниеОшибки());
				ОтсутствующиеИменаТаблиц.Добавить(ИмяТаблицы);
			КонецПопытки;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат ОтсутствующиеИменаТаблиц;
	
КонецФункции

Функция НайтиИменаТаблицПоРасположениюСлов(Знач Текст, ПервоеИскомоеСлово, ВтороеИскомоеСлово = "")
	
	СписокИгнорируемыхСимволов = Новый СписокЗначений;
	СписокИгнорируемыхСимволов.Добавить(Символы.ПС);
	СписокИгнорируемыхСимволов.Добавить(Символы.ВК);
	СписокИгнорируемыхСимволов.Добавить(Символы.НПП);
	СписокИгнорируемыхСимволов.Добавить(Символы.Таб);
	СписокИгнорируемыхСимволов.Добавить(" ");
	
	СписокРазделителей = Новый СписокЗначений;
	СписокРазделителей.Добавить("(");
	СписокРазделителей.Добавить(")");
	СписокРазделителей.Добавить(".");
	СписокРазделителей.Добавить(",");
	СписокРазделителей.Добавить(";");
	СписокРазделителей.Добавить("&");
	
	НайденныеИмена = Новый Структура;
	ПервоеИскомоеСлово = ВРег(ПервоеИскомоеСлово);
	ВтороеИскомоеСлово = ВРег(ВтороеИскомоеСлово);
	
	Пока Истина Цикл
		
		Найдено = Найти(Текст, " " + ВРег(ПервоеИскомоеСлово) + " ");
		Если Найдено > 0 Тогда
			
			Текст = СокрЛП(Прав(Текст, СтрДлина(Текст) - Найдено - СтрДлина(ПервоеИскомоеСлово) - 1));
			СоставляемоеСлово = "";
			НайденноеСлово = "";
			
			Для НомерСтроки = 1 По СтрДлина(Текст) Цикл
				
				ОчереднойСимвол = Сред(Текст, НомерСтроки, 1);
				
				Если НЕ СписокРазделителей.НайтиПоЗначению(ОчереднойСимвол) = Неопределено Тогда
					
					СоставляемоеСлово = "";
					НайденноеСлово = "";
					
					Прервать;
					
				ИначеЕсли НЕ СписокИгнорируемыхСимволов.НайтиПоЗначению(ОчереднойСимвол) = Неопределено Тогда
					
					Если СоставляемоеСлово = "" Тогда
						Продолжить;
					Иначе
						Если НайденноеСлово = "" Тогда
							
							НайденноеСлово = СоставляемоеСлово;
							СоставляемоеСлово = "";
							
							Если ВтороеИскомоеСлово = "" Тогда
								Прервать;
							КонецЕсли;
							
						Иначе
							
							Если НЕ СоставляемоеСлово = ВтороеИскомоеСлово Тогда
								НайденноеСлово = "";
							КонецЕсли;
							
							Прервать;
							
						КонецЕсли;
					КонецЕсли;
				Иначе
					СоставляемоеСлово = СоставляемоеСлово + ОчереднойСимвол;
				КонецЕсли;
				
			КонецЦикла;
			
			Если НЕ НайденноеСлово = "" Тогда
				НайденныеИмена.Вставить(НайденноеСлово, Найдено);
			КонецЕсли;
		Иначе
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НайденныеИмена;
	
КонецФункции

#Область ПользовательскиеФункции

// Процедура - Подставить параметры в функцию
//
// Параметры:
//  Текст		 - Строка - Исходный текст
//  Параметры	 - Структура - Подготовленные параметры для выполнения пользовательской функции
//   * Ключ - Строка - Имя параметра
//   * Значение - Произвольный - Значение параметра
//  Выборка		 - ВыборкаИзРезультатаЗапроса - Проверямые параметры функции.
//   * Наименование - Строка - Имя параметра
//   * Необязательный - Булево - Если Необязательный = Ложь и параметра нет в структуре параметров,
//         то функция не будет выполнена
//   * Тип - Строка - Представление типа значения параметра
//  Отказ		 - Булево
// 
// Возвращаемое значение:
//  Структура - Заполненные параметры.
//   * Ключ - Строка - Имя параметра;
//   * Значение - Произвольный - Значение подставляемого параметра.
//
Функция ПодставитьПараметрыВФункцию(Текст, Параметры, Выборка, Отказ = Ложь)

	ВозвращаемыеПараметры = Новый Структура;
	Пока Выборка.Следующий() Цикл
		Значение = Неопределено;
		Если Параметры.Свойство(Выборка.Наименование, Значение) Тогда
			ТипПараметра = ТипЗнч(Значение);
			Если ТипПараметра <> Тип(Выборка.Тип) Тогда
				ТекстСообщения = СтрШаблон(НСтр("ru='Тип значения параметра %1 - %2. Допустимый - %3!'"),
					Выборка.Наименование,
					ТипПараметра,
					Выборка.Тип);
				пбп_Переадресация.СообщитьПользователю(ТекстСообщения, , , , Отказ);
			КонецЕсли;
		ИначеЕсли Выборка.Необязательный = Ложь Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru='Параметр: %1, является обязательным!'"), Выборка.Наименование);
			пбп_Переадресация.СообщитьПользователю(ТекстСообщения, , , , Отказ);
		КонецЕсли;
		
		Если Отказ Тогда
			Продолжить;
		КонецЕсли;
		
		ВозвращаемыеПараметры.Вставить(Выборка.Наименование, Значение);
		ЗаменаПодстроки(Текст, Выборка.Наименование, "Параметры.");
	КонецЦикла;
	
	Возврат ВозвращаемыеПараметры;
	
КонецФункции

// Предназначена для поиска и замены параметров в исходной строке,
// замена по ключу происходит в случае если перед ключом стоит не буквенно-числовой символ.
//
// Параметры:
//  Текст	 - Строка - Исходный текст
//  Ключ	 - Строка - По ключу осуществляется поиск и замена
//  Префикс	 - Строка - Для инициализации параметров и переменных при выполнении пользовательской функции
//
Процедура ЗаменаПодстроки(Текст, Ключ, Префикс)
	
	Позиция = СтрНайти(Текст, Ключ);
	Пока Позиция > 0 Цикл
		
		СимволДо = ?(Позиция = 1, "", Сред(Текст, Позиция - 1, 1));
		КодДо = КодСимвола(НРег(СимволДо));
		
		СимволПосле = Сред(Текст, Позиция + СтрДлина(Ключ), 1);
		КодПосле = КодСимвола(НРег(СимволПосле));
		
		ДлинаПрефикса = 0;
		Если ЭтоДопустимыйСимвол(КодДо) И ЭтоДопустимыйСимвол(КодПосле) Тогда
			Текст = СтрЗаменить(Текст, СимволДо + Ключ + СимволПосле, СимволДо + Префикс + Ключ + СимволПосле);
			ДлинаПрефикса = СтрДлина(Префикс);
		КонецЕсли;
		
		Позиция = СтрНайти(Текст, Ключ, НаправлениеПоиска.СНачала, Позиция + ДлинаПрефикса + 1);
		
	КонецЦикла;
	
КонецПроцедуры

// Проверка на допустимость символа, недопустимым является любой буквенно-цифровой символ,
// а также любые региональные символы после 7Fh
//
// Параметры:
//  КодСимвола	 - Число - см. КодСимвола
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоДопустимыйСимвол(КодСимвола)
	
	Если КодСимвола >= 48 И КодСимвола <= 57 // Цифры
		Или КодСимвола >= 97 И КодСимвола <= 122 // (en) буквы
		Или КодСимвола > 127 // региональные коды
		Или КодСимвола = 46 Или КодСимвола = 34 Тогда // точка(.), кавычка(")
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область УсловныеВызовы

// Возвращает серверный модуль менеджера по имени объекта.
//
// Параметры:
//  Имя	 - Строка - Имя вычисляемого модуля
// 
// Возвращаемое значение:
//  МодульМенеджера - Модуль менеджера объекта метаданных
//
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	КоличествоЧастейИмени = 2;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = КоличествоЧастейИмени Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение(пбп_ПереадресацияКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра %1 в функции %2. Объект метаданных ""%3"" не существует.'"), 
			"Имя", "пбп_ОбщегоНазначенияСервер.СерверныйМодульМенеджера", Имя),
			КатегорияОшибки.ОшибкаКонфигурации);
	КонецЕсли;
	
	// BSLLS:ExecuteExternalCodeInCommonModule-off
	// ВычислитьВБезопасномРежиме не используется, чтобы избежать вызова ОбщийМодуль рекурсивно.
	УстановитьБезопасныйРежим(Истина);
	Модуль = Вычислить(Имя);
	// BSLLS:ExecuteExternalCodeInCommonModule-on
	
	Возврат Модуль;
	
КонецФункции

#КонецОбласти

#КонецОбласти // СлужебныеПроцедурыИФункции
