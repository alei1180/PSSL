// Библиотека проектных подсистем для упрощения разработки архитектуры на 1С: Предприятие 8,
// включая доработку типовых конфигураций.
//
// Copyright First BIT company
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
// URL:    https://github.com/firstBitSportivnaya/PSSL/
//

#Область ПрограммныйИнтерфейс

// Инициализирует таблицу со свойствами колонок загружаемого файла
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица готовая для заполнения данных колонок
//
Функция ИнициализироватьТаблицуСоСвойствамиКолонок() Экспорт
	
	СвойстваКолонок = Новый ТаблицаЗначений;
	ДлинаСтроки = 150;
	СвойстваКолонок.Колонки.Добавить("ИмяКолонки"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("ИмяВТабДоке"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("Группа"			, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("ТипЗначения"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("ПолеПоиска1"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("ПолеПоиска2"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	СвойстваКолонок.Колонки.Добавить("ПолеПоиска3"		, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтроки));
	// BSLLS:MagicNumber-off
	СвойстваКолонок.Колонки.Добавить("ОператорУсловия"		, пбп_Переадресация.ОписаниеТипаСтрока(4));
	СвойстваКолонок.Колонки.Добавить("ФункцияПреобразования", пбп_Переадресация.ОписаниеТипаСтрока(300));
	СвойстваКолонок.Колонки.Добавить("ФорматДаты"			, пбп_Переадресация.ОписаниеТипаСтрока(300));
	// BSLLS:MagicNumber-on
	
	Возврат СвойстваКолонок;
	
КонецФункции

// Инициализирует таблицу со свойствами колонок загружаемого CSV-файла.
//	В отличие от ИнициализироватьТаблицуСоСвойствамиКолонок добавляются две колонки:
//	  - Начало - Число - порядковый номер символа, с которой начинается значение колонки строки файла;
//	  - Длина - Число - длина значения от начала в строке файла
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица готовая для заполнения данных колонок
//
Функция ИнициализироватьТаблицуСоСвойствамиCSV() Экспорт
	
	ТаблицаСвойств = ИнициализироватьТаблицуСоСвойствамиКолонок();
	// BSLLS:MagicNumber-off
	ОписаниеЧислаНачала = пбп_Переадресация.ОписаниеТипаЧисло(5, 0, ДопустимыйЗнак.Неотрицательный);
	ОписаниеЧислаДлина = пбп_Переадресация.ОписаниеТипаЧисло(5, 0, ДопустимыйЗнак.Неотрицательный);
	// BSLLS:MagicNumber-on
	ТаблицаСвойств.Колонки.Добавить("Начало", ОписаниеЧислаНачала);
	ТаблицаСвойств.Колонки.Добавить("Длина", ОписаниеЧислаДлина);
	
	Возврат ТаблицаСвойств;
	
КонецФункции

// Получить параметры чтения файла
//
//  - НазваниеЛиста					 - Строка - наименование листа, с которого необходимо выполнить загрузку данных
//  - НомерСтроки					 - Число - номер первой строки листа, с которой начинается парсинг данных
//  - СопоставлениеПоНаименованию	 - Булево - если Истина, то колонки макета сопоставляются с табличным документом по
//  наименованию; если Ложь, то сопоставляются в последовательности колонок макета, а наименования игнорируются.
//  - КонвертироватьДаты			 - Булево - конвертировать значения с типом дата из строки в дату
//  - ЗначениеИстина				 - Строка - строковое значение, при котором значение булево будет Истина
//  - ОставитьСтроковыеЗначения		 - Булево - если истина, то оставляет колонки с исходными строковыми значениями
//	конвертируемых типов: Булево, Число, Дата
//  - ИскатьПомеченныеНаУдаление	 - Булево - если истина, то при поиске ссылок игнорирует пометку на удаление
//
// Возвращаемое значение:
//  Структура - параметры чтения
//
Функция ПолучитьПараметрыЧтенияФайла() Экспорт
	
	ПараметрыЧтения = Новый Структура;
	ПараметрыЧтения.Вставить("НазваниеЛиста"					, "");
	ПараметрыЧтения.Вставить("НомерСтроки"						, 0);
	ПараметрыЧтения.Вставить("СопоставлениеПоНаименованию"		, Ложь);
	ПараметрыЧтения.Вставить("КонвертироватьДаты"				, Истина);
	ПараметрыЧтения.Вставить("ВыдаватьОшибкуПриОтсутствииЛиста"	, Ложь);
	ПараметрыЧтения.Вставить("ЗначениеИстина"					, "");
	ПараметрыЧтения.Вставить("ОставитьСтроковыеЗначения"		, Ложь);
	ПараметрыЧтения.Вставить("ИскатьПомеченныеНаУдаление"		, Истина);
	
	Возврат ПараметрыЧтения;
	
КонецФункции

// Конвертирует данные табличного документа в таблицу значений по переданному макету
//
// Параметры:
//  АдресВХранилище		 - Строка - Адрес файла во временном хранилище
//  Расширение			 - Строка - Расширение файла (xls, xlsx)
//  Макет				 - ТаблицаЗначений - в таблице указано имя колонок, их тип и поле поиска ссылочного типа
//  ПараметрыЧтения		 - Структура - см. ПолучитьПараметрыЧтенияФайла
// 
// Возвращаемое значение:
//  Строка, ТаблицаЗначений - таблица с данными файла или сообщение об ошибке
//
Функция КонвертироватьДанныеТабличногоДокументаВТаблицуЗначений(
	АдресВХранилище, Расширение, Макет, ПараметрыЧтения) Экспорт
	
	НазваниеЛиста = ПараметрыЧтения.НазваниеЛиста;
	НомерСтроки = ПараметрыЧтения.НомерСтроки;
	СопоставлениеПоНаименованию = ПараметрыЧтения.СопоставлениеПоНаименованию;
	КонвертироватьДаты = ПараметрыЧтения.КонвертироватьДаты;
	ВыдаватьОшибку = ПараметрыЧтения.ВыдаватьОшибкуПриОтсутствииЛиста;
	ЗначениеИстина = ПараметрыЧтения.ЗначениеИстина;
	ОставитьСтроковые = ПараметрыЧтения.ОставитьСтроковыеЗначения;
	ИскатьПомеченныеНаУдаление = ПараметрыЧтения.ИскатьПомеченныеНаУдаление;
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВХранилище);
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Расширение);
	ДвоичныеДанные.Записать(ИмяВременногоФайла);
	
	ТабДок = Новый ТабличныйДокумент;
	ТабДок.Прочитать(ИмяВременногоФайла, СпособЧтенияЗначенийТабличногоДокумента.Текст);
	
	Попытка
		// BSLLS:UsingSynchronousCalls-off
		УдалитьФайлы(ИмяВременногоФайла);
		// BSLLS:UsingSynchronousCalls-on
	Исключение
		ТекстОшибки = НСтр("ru = 'Загрузка файла через табличный документ.Удаление временного файла'");
		ЗаписьЖурналаРегистрации(ТекстОшибки,
			УровеньЖурналаРегистрации.Ошибка, , ,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Лист = ?(ЗначениеЗаполнено(НазваниеЛиста), Табдок.Области.Найти(СтрЗаменить(НазваниеЛиста, " ", "_")), Неопределено);
	
	Если ВыдаватьОшибку И Лист = Неопределено Тогда
		СообщениеОбОшибке = НСтр("ru = 'Лист с указанным именем " + НазваниеЛиста + " не найден';");
		Возврат СообщениеОбОшибке;
	КонецЕсли;
	
	ПервыйЛист = ТабДок.Области[0].Имя;
	Для Каждого ЛистДок Из ТабДок.Области Цикл
		Если ЛистДок.Верх = 1 Тогда
			ПервыйЛист = ЛистДок.Имя;
		КонецЕсли;
	КонецЦикла;
	
	ТабДок = ТабДок.ПолучитьОбласть(?(Лист = Неопределено, ПервыйЛист, СтрЗаменить(НазваниеЛиста, " ", "_")));
	ТЗ = ПолучитьПромежуточнуюТаблицуЗначенийИзТабличногоДокумента(
		ТабДок, НомерСтроки, Макет, СопоставлениеПоНаименованию);
	
	ГотоваяТаблица = ПреобразоватьСтроковыеЗначенияПоТипамСвойств(ТЗ, Макет,
		КонвертироватьДаты, ЗначениеИстина, ОставитьСтроковые, ИскатьПомеченныеНаУдаление);
	
	Возврат ГотоваяТаблица;
	
КонецФункции

// Читает CSV-файл и выводит их в таблицу значений, заполненной согласно структуре макета
//
// Параметры:
//  ПутьКФайлу		 - Строка - путь к csv-файлу во временном хранилище
//  СтруктураМакета	 - ТаблицаЗначений - в таблице указано имя колонок, их тип и поле поиска ссылочного типа
//  Кодировка		 - Строка - кодировка текста файла
//  Разделитель		 - Строка - разделитель значений
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с данными, прочитанными из CSV-файла
//
Функция ПолучитьПромежуточнуюТаблицуИзCSVФайла(ПутьКФайлу, СтруктураМакета, Кодировка = "UTF8", Разделитель = "") Экспорт
	
	ДлинаСтрокиКолонки = 300;
	
	СыраяТаблица = Новый ТаблицаЗначений;
	Для Каждого КолонкаТаблицы Из СтруктураМакета Цикл
		СыраяТаблица.Колонки.Добавить(КолонкаТаблицы.ИмяКолонки, пбп_Переадресация.ОписаниеТипаСтрока(ДлинаСтрокиКолонки));
	КонецЦикла;
	
	ЗагружаемыйФайл = Новый ЧтениеТекста(ПутьКФайлу, Кодировка);
	
	НомерСтроки = 1;
	ТекущаяСтрока = ЗагружаемыйФайл.ПрочитатьСтроку();
	Пока ТекущаяСтрока <> Неопределено Цикл
		Если НомерСтроки < 2 Тогда // в первой заголовок
			НомерСтроки = НомерСтроки + 1;
			ТекущаяСтрока = ЗагружаемыйФайл.ПрочитатьСтроку();
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = СыраяТаблица.Добавить();
		
		Если Разделитель = "" Тогда
			Для Каждого СвойстваКолонок Из СтруктураМакета Цикл
				Если Не ЗначениеЗаполнено(СвойстваКолонок.Начало) Тогда
					Продолжить;
				КонецЕсли;
				
				ЗначениеКолонки = Сред(ТекущаяСтрока, СвойстваКолонок.Начало, СвойстваКолонок.Длина);
				ЗначениеБезПробелов = СокрЛП(ЗначениеКолонки);
				НоваяСтрока[СвойстваКолонок.ИмяКолонки] = ЗначениеБезПробелов;
			КонецЦикла;
		Иначе
			Если Прав(ТекущаяСтрока, 1) = Разделитель Тогда
				ТекущаяСтрокаБезОкончания = Сред(ТекущаяСтрока, 1, СтрДлина(ТекущаяСтрока) - 1);
			Иначе
				ТекущаяСтрокаБезОкончания = ТекущаяСтрока;
			КонецЕсли;
			
			МассивКолонок = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				ТекущаяСтрокаБезОкончания, Разделитель, Ложь, Истина);
			// Количество разделителей должно быть равно количеству строк колонок макета, иначе строка не будет загружена
			КоличествоКолонок = МассивКолонок.Количество();
			Если КоличествоКолонок = 0 Или КоличествоКолонок <> СтруктураМакета.Количество() Тогда
				Продолжить;
			КонецЕсли;
			
			Для Инкремент = 0 По СтруктураМакета.Количество() - 1 Цикл
				СвойстваКолонок = СтруктураМакета[Инкремент];
				ЗначениеБезПробелов = СокрЛП(МассивКолонок[Инкремент]);
				НоваяСтрока[СвойстваКолонок.ИмяКолонки] = ЗначениеБезПробелов;
			КонецЦикла;
		КонецЕсли;
		
		НомерСтроки = НомерСтроки + 1;
		ТекущаяСтрока = ЗагружаемыйФайл.ПрочитатьСтроку();
	КонецЦикла;
	
	ЗагружаемыйФайл.Закрыть();
	
	Для Каждого КолонкаТаблицы Из СтруктураМакета Цикл
		Если КолонкаТаблицы.ТипЗначения = "Дата" Тогда
			СыраяТаблица.Колонки[КолонкаТаблицы.ИмяКолонки].Имя
				= СыраяТаблица.Колонки[КолонкаТаблицы.ИмяКолонки].Имя + "Строкой";
			СыраяТаблица.Колонки.Добавить(КолонкаТаблицы.ИмяКолонки, Новый ОписаниеТипов("Дата"));
		КонецЕсли;
	КонецЦикла;
	
	СыраяТаблица.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число"));
	
	Возврат СыраяТаблица;
	
КонецФункции

// Преобразовывает строковые значения по типам свойств макета
//
// Параметры:
//  ТЗ							 - ТаблицаЗначений	 - промежуточная таблица со значениями в типе строка
//  Макет						 - ТаблицаЗначений	 - в таблице указано имя колонок, их тип и поле поиска ссылочного типа
//  КонвертироватьДаты			 - Булево			 - конвертировать значения с типом дата из строки в дату
//  ЗначениеИстина				 - Строка			 - строковое значение, при котором значение булево будет Истина
//  ОставитьСтроковые			 - Булево			 - если истина, то оставляет колонки с исходными строковыми значениями
//			конвертируемых типов: Булево, Число, Дата
//  ИскатьПомеченныеНаУдаление	 - Булево			 - если истина, то при поиске ссылок игнорирует пометку на удаление
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с конвертированными данными
//
Функция ПреобразоватьСтроковыеЗначенияПоТипамСвойств(ТЗ, Макет, КонвертироватьДаты = Ложь,
	ЗначениеИстина = "", ОставитьСтроковые = Ложь, ИскатьПомеченныеНаУдаление = Истина) Экспорт
	
	КоллекцияОтборов = Новый ТаблицаЗначений;
	КоллекцияОтборов.Колонки.Добавить("ТипДанных");
	КоллекцияОтборов.Колонки.Добавить("НомерСтрокиДочерней");
	КоллекцияОтборов.Колонки.Добавить("МассивДанных");
	КоллекцияОтборов.Колонки.Добавить("НазваниеКолонки");
	
	Н = ТЗ.Количество() - 1;
	
	Пока Не Н < 0 Цикл
		
		Счетчик = 0;
		ТЗ[Н].ПорядковыйНомер = Н;
		
		Для Каждого Колонка Из ТЗ.Колонки Цикл
			Если Не ЗначениеЗаполнено(ТЗ[Н][Колонка.Имя]) Тогда
				Счетчик = Счетчик + 1;
			КонецЕсли;
		КонецЦикла;
		
		Если Счетчик = ТЗ.Колонки.Количество() Тогда
			ТЗ.Удалить(Н);
		КонецЕсли;
		
		Н = Н - 1;
		
	КонецЦикла;
	
	ВставкаВТ					= "";
	ВставкаБазовые				= "";
	ВставкаСсылочные			= "";
	ВставкаИсточники			= "";
	ХранилищеИсточников			= Новый Соответствие;
	МассивИменСсылочных			= Новый Массив;
	СтруктураИменКолонокДат		= Новый Структура;
	МассивИменКолонокЧисел		= Новый Массив;
	МассивИменКолонокБулево		= Новый Массив;
	СоответствиеПеречислений	= Новый Соответствие;
	КолонкиСПреобразованием		= Новый Структура;
	
	ДлинаЧисла = 15;
	ЧислоСтрока = "Число";
	ОписаниеТипаЧисло15 = Новый ОписаниеТипов(ЧислоСтрока, , , Новый КвалификаторыЧисла(ДлинаЧисла));
	ШаблонИмяКолонки = "ВходнаяТаблица.%1 КАК %1," + Символы.ПС;
	СтрокаНеОбрабатывать = "НеОбрабатывать";
	СсылкаСтрока = "Ссылка";
	КодЧисломСтрока = "КодЧислом";
	ВходнаяТаблицаСтрока = "ВходнаяТаблица.";
	
	Для Каждого СтрокаТаблицы Из Макет Цикл
		
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		
		ВставкаВТ = ВставкаВТ + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
		
		Если СтрНайти(СтрокаТаблицы.ТипЗначения, СсылкаСтрока) <> 0
			И СтрНайти(СтрокаТаблицы.ТипЗначения, "Перечисление") = 0 Тогда
			
			ТЗ.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки + КодЧисломСтрока, ОписаниеТипаЧисло15);
			ВставкаВТ = ВставкаВТ + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки + КодЧисломСтрока);
			МассивИменСсылочных.Добавить(СтрокаТаблицы.ИмяКолонки);
			
			РазбивкаТипа = СтрРазделить(СтрЗаменить(СтрокаТаблицы.ТипЗначения, СсылкаСтрока, ""), ".", Ложь);
			ИмяОбъекта = РазбивкаТипа[1];
			
			ВхождениеИсточника = ХранилищеИсточников.Получить(ИмяОбъекта);
			ХранилищеИсточников.Вставить(ИмяОбъекта, ?(ВхождениеИсточника = Неопределено, 1, ВхождениеИсточника + 1));
			Итерация = ?(ХранилищеИсточников.Получить(ИмяОбъекта) = 0, "", Строка(ХранилищеИсточников.Получить(ИмяОбъекта)));
			
			// В макете могут быть заявлены поля, для которых не назначили полей поиска
			ЕстьПоляПоиска = ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска1)
				Или ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска2)
				Или ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска3);
			Если ЕстьПоляПоиска Тогда
				ВставкаСсылочные = ВставкаСсылочные + ИмяОбъекта + Итерация
					+ ".Ссылка КАК " + СтрокаТаблицы.ИмяКолонки + "," + Символы.ПС;
			Иначе
				ВставкаСсылочные = ВставкаСсылочные + "НЕОПРЕДЕЛЕНО КАК "
					 + СтрокаТаблицы.ИмяКолонки + "," + Символы.ПС;
			КонецЕсли;
			
			ОператорУсловия = ?(ПустаяСтрока(СтрокаТаблицы.ОператорУсловия),
				"ИЛИ", СтрокаТаблицы.ОператорУсловия);
			
			Если ЗначениеЗаполнено(СтрокаТаблицы.ФункцияПреобразования) Тогда
				КолонкиСПреобразованием.Вставить(СтрокаТаблицы.ИмяКолонки, СтрокаТаблицы.ФункцияПреобразования);
			КонецЕсли;
			
			Если Не СтрНайти(ВставкаИсточники, " " + ИмяОбъекта + " ") > 0 И ЕстьПоляПоиска Тогда
				ВставкаУсловияСоединения = "";
				Для Инкремент = 1 По 3 Цикл
					РеквизитСравнения = СтрокаТаблицы["ПолеПоиска" + Инкремент];
					Если ПустаяСтрока(РеквизитСравнения) Тогда
						Продолжить;
					КонецЕсли;
					
					// Возможно использование оператора И для сопоставления, но при его использовании
					// имена полей поиска должны равняться именам колонок обрабатываемой таблицы. Например:
					// Если в свойствах макета у колонки заполнен тип ДокументСсылка., ПолеПоиска1 = "Номер",
					// а ПолеПоиска2 = "Дата" И ОператорУсловия = "И", тогда таблица построителя должна иметь
					// колонки "Номер", где лежит номер документа и "Дата", где лежит дата документа.
					Если ВРег(ОператорУсловия) = "ИЛИ" Тогда
						ИмяКолонкиСравнения = СтрокаТаблицы.ИмяКолонки;
					Иначе
						ИмяКолонкиСравнения = РеквизитСравнения;
					КонецЕсли;
					
					ВставкаУсловияСоединения = ВставкаУсловияСоединения
						+ ?(ПустаяСтрока(ВставкаУсловияСоединения), "", Символы.ПС + "
						|		" + ВРег(ОператорУсловия) + " ") + ВходнаяТаблицаСтрока + ИмяКолонкиСравнения
						+ " = " + ИмяОбъекта + Итерация + "." + РеквизитСравнения;
				КонецЦикла;
				
				Если Не ИскатьПомеченныеНаУдаление Тогда
					УсловиеНаПомеченные = "
					|		И НЕ " + ИмяОбъекта + Итерация + ".ПометкаУдаления";
				КонецЕсли;
				
				Если Не ПустаяСтрока(ВставкаУсловияСоединения) Тогда
					Если ВРег(ОператорУсловия) = "И" Или ВРег(ОператорУсловия) = "ВИРТ" Тогда
						ВставкаИсточники = ВставкаИсточники + "
						|		ЛЕВОЕ СОЕДИНЕНИЕ " + СтрЗаменить(СтрокаТаблицы.ТипЗначения, СсылкаСтрока, "")
						+ " КАК " + ИмяОбъекта + Итерация + "
						|		ПО (" + ВставкаУсловияСоединения + ")" + УсловиеНаПомеченные;
					Иначе
						ВставкаИсточники = ВставкаИсточники + "
						|		ЛЕВОЕ СОЕДИНЕНИЕ " + СтрЗаменить(СтрокаТаблицы.ТипЗначения, СсылкаСтрока, "")
						+ " КАК " + ИмяОбъекта + Итерация + "
						|		ПО ВходнаяТаблица." + СтрокаТаблицы.ИмяКолонки + " <> """" И "
						+ ВходнаяТаблицаСтрока + СтрокаТаблицы.ИмяКолонки + " <> 0
						|		И (" + ВставкаУсловияСоединения + ")" + УсловиеНаПомеченные;
					КонецЕсли;
				КонецЕсли;
				
				ВставкаБазовые = ВставкаБазовые + ВходнаяТаблицаСтрока + СтрокаТаблицы.ИмяКолонки
					+ " КАК " + СтрокаТаблицы.ИмяКолонки + "Служебный," + Символы.ПС;
			КонецЕсли;
			
		ИначеЕсли СтрНайти(СтрокаТаблицы.ТипЗначения, "Перечисление") <> 0 Тогда
			КолонкаПеречисления = ТЗ.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки + СтрокаНеОбрабатывать,
				Новый ОписаниеТипов(СтрокаТаблицы.ТипЗначения));
			СоответствиеПеречислений.Вставить(СтрокаТаблицы.ИмяКолонки, СтрокаТаблицы.ТипЗначения);
			ВставкаВТ = СтрЗаменить(ВставкаВТ, "." + СтрокаТаблицы.ИмяКолонки + " КАК", "." + КолонкаПеречисления.Имя + " КАК");
			ВставкаБазовые = ВставкаБазовые + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
		ИначеЕсли Не СтрНайти(СтрокаТаблицы.ИмяКолонки, СтрокаНеОбрабатывать) > 0 Тогда
			ВставкаБазовые = ВставкаБазовые + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
			Если ТЗ.Колонки.Найти(СтрокаТаблицы.ИмяКолонки + "Строкой") <> Неопределено Тогда
				Если ОставитьСтроковые Тогда
					ВставкаВТ = ВставкаВТ + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки + "Строкой");
					ВставкаБазовые = ВставкаБазовые + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки + "Строкой");
				КонецЕсли;
				
				Если СтрНайти(СтрокаТаблицы.ТипЗначения, "Дата") <> 0 Тогда
					СтруктураИменКолонокДат.Вставить(СтрокаТаблицы.ИмяКолонки, СтрокаТаблицы.ФорматДаты);
				ИначеЕсли СтрНайти(СтрокаТаблицы.ТипЗначения, ЧислоСтрока) <> 0 Тогда
					МассивИменКолонокЧисел.Добавить(СтрокаТаблицы.ИмяКолонки);
				ИначеЕсли СтрНайти(СтрокаТаблицы.ТипЗначения, "Булево") <> 0 Тогда
					МассивИменКолонокБулево.Добавить(СтрокаТаблицы.ИмяКолонки);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	ВставкаВТ		= ВставкаВТ + "ВходнаяТаблица.ПорядковыйНомер Как ПорядковыйНомер";
	КоличествоСимволовЛев = 2;
	ВставкаБазовые	= Лев(ВставкаБазовые, СтрДлина(ВставкаБазовые) - КоличествоСимволовЛев);
	
	Если КонвертироватьДаты Тогда
		ПрисвоитьНомераФорматовКолонокДат(ТЗ, СтруктураИменКолонокДат);
	КонецЕсли;
	
	ИмяСобытия = НСтр("ru = 'Загрузка файла через табличный документ'");
	КомментарийОшибки = "ru = 'Не удалось выполнить функцию преобразования %1 для колонки %2. Подробно: %3';";
	
	Для Каждого СтрокаТаблицы Из ТЗ Цикл
		
		Для Каждого ИмяМассива Из МассивИменСсылочных Цикл
			СтрокаТаблицы[ИмяМассива + КодЧисломСтрока] = ОписаниеТипаЧисло15.ПривестиЗначение(СтрокаТаблицы[ИмяМассива]);
		КонецЦикла;
		
		Для Каждого Колонка Из СоответствиеПеречислений Цикл
			ИмяПеречисления = СтрЗаменить(Колонка.Значение, "ПеречислениеСсылка.", "");
			
			Для Каждого ТекЭлемент Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
				Если НРег(ТекЭлемент.Синоним) = НРег(СтрокаТаблицы[Колонка.Ключ]) Тогда
					СтрокаТаблицы[Колонка.Ключ + СтрокаНеОбрабатывать] = Перечисления[ИмяПеречисления][ТекЭлемент.Имя];
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЦикла;
		
		Для Каждого КлючИЗначение Из КолонкиСПреобразованием Цикл
			Попытка
				Параметры = Новый Массив;
				Параметры.Добавить(СтрокаТаблицы[КлючИЗначение.Ключ]);
				СтрокаТаблицы[КлючИЗначение.Ключ] = пбп_Переадресация.ВызватьФункциюКонфигурации(
					КлючИЗначение.Значение, Параметры);
			Исключение
				СообщениеОбОшибке = СтрШаблон(КомментарийОшибки, КлючИЗначение.Значение,
					КлючИЗначение.Ключ, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				пбп_Переадресация.ДобавитьСообщениеДляЖурналаРегистрации(ИмяСобытия,
					УровеньЖурналаРегистрации.Ошибка, , , НСтр(СообщениеОбОшибке));
			КонецПопытки;
		КонецЦикла;
		
		Если КонвертироватьДаты Тогда
			Для Каждого КлючИЗначение Из СтруктураИменКолонокДат Цикл
				СтрокаТаблицы[КлючИЗначение.Ключ] = ПреобразоватьДатуИзСтрокиПоФормату(
					СтрокаТаблицы[КлючИЗначение.Ключ + "Строкой"], КлючИЗначение.Значение);
			КонецЦикла;
		КонецЕсли;
		
		Для Каждого ИмяКолонкиЧисло Из МассивИменКолонокЧисел Цикл
			Если ПустаяСтрока(СтрокаТаблицы[ИмяКолонкиЧисло + "Строкой"]) Тогда
				СтрокаТаблицы[ИмяКолонкиЧисло] = 0;
			Иначе
				СтроковоеЗначение = СтрокаТаблицы[ИмяКолонкиЧисло + "Строкой"];
				СтрокаТаблицы[ИмяКолонкиЧисло] = ПреобразоватьЧислоИзСтроки(СтроковоеЗначение);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ИмяКолонкиБулево Из МассивИменКолонокБулево Цикл
			Если ПустаяСтрока(ЗначениеИстина) Тогда
				СтрокаТаблицы[ИмяКолонкиБулево] = НСтр(СтрокаТаблицы[ИмяКолонкиБулево + "Строкой"]) = "да"
					Или НСтр(СтрокаТаблицы[ИмяКолонкиБулево + "Строкой"]) = "истина";
			Иначе
				СтрокаТаблицы[ИмяКолонкиБулево] = НСтр(СтрокаТаблицы[ИмяКолонкиБулево + "Строкой"]) = НСтр(ЗначениеИстина);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	#ВставкаВТ
	|ПОМЕСТИТЬ ВходнаяТаблица
	|ИЗ
	|	&ВходнаяТаблица КАК ВходнаяТаблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	#ВставкаСсылочные
	|	#ВставкаБазовые
	|ИЗ
	|	ВходнаяТаблица КАК ВходнаяТаблица
	|		#ВставкаИсточники
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВходнаяТаблица.ПорядковыйНомер";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаВТ", ВставкаВТ);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаСсылочные", ВставкаСсылочные);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаБазовые", ВставкаБазовые);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаИсточники", ВставкаИсточники);
	
	Запрос.УстановитьПараметр("ВходнаяТаблица", ТЗ);
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыгрузкаРезультатаЗапроса = РезультатЗапроса.Выгрузить();
	
	Возврат ВыгрузкаРезультатаЗапроса;
	
КонецФункции

// Возвращает таблицу значений без null в ячейках
//
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений - таблица, в которой необходимо подменить значения
//  фИзменилиТаблицу - Булево - флаг, оповещающий о том, что в таблице были выполнены замены
//
Процедура ТаблицаЗначенийБезNull(ТаблицаЗначений, фИзменилиТаблицу = Ложь) Экспорт
	
	фИзменилиТаблицу = Ложь;
	
	чКрайний = ТаблицаЗначений.Колонки.Количество() - 1;
	Для чИндекс = 0 По чКрайний Цикл
		
		ТипКолонки = ТаблицаЗначений.Колонки[чИндекс].ТипЗначения;
		
		Если ТипКолонки.СодержитТип(Тип("Null")) Тогда
			
			ИмяКолонки			= ТаблицаЗначений.Колонки[чИндекс].Имя;
			ЗаголовокКолонки	= ТаблицаЗначений.Колонки[чИндекс].Заголовок;
			ШиринаКолонки		= ТаблицаЗначений.Колонки[чИндекс].Ширина;
			ЗначениеКолонки		= ТаблицаЗначений.ВыгрузитьКолонку(чИндекс);
			ТипКолонки = Новый ОписаниеТипов(ТипКолонки, ,"NULL",
				ТипКолонки.КвалификаторыЧисла,
				ТипКолонки.КвалификаторыСтроки,
				ТипКолонки.КвалификаторыДаты,
				ТипКолонки.КвалификаторыДвоичныхДанных);
			
			ТаблицаЗначений.Колонки.Удалить(чИндекс);
			ТаблицаЗначений.Колонки.Вставить(чИндекс, ИмяКолонки, ТипКолонки, ЗаголовокКолонки, ШиринаКолонки);
			ТаблицаЗначений.ЗагрузитьКолонку(ЗначениеКолонки, чИндекс);
			
			фИзменилиТаблицу = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьПромежуточнуюТаблицуЗначенийИзТабличногоДокумента(
	ТабДок, НомерСтроки, Макет, СопоставлениеПоНаименованию)
	
	Если Не НомерСтроки = 1 Тогда
		ТабДок.УдалитьОбласть(ТабДок.Область("R1:R" + Строка(НомерСтроки - 1)), ТипСмещенияТабличногоДокумента.ПоВертикали);
	КонецЕсли;
	
	Если Не СопоставлениеПоНаименованию Тогда
		ПреобразоватьТабличныйДокументПоследовательнымСопоставлением(ТабДок, Макет);
	Иначе
		ПреобразоватьТабличныйДокументСопоставлениемПоНаименованиюКолонок(ТабДок, Макет);
	КонецЕсли;
	
	ПЗ							= Новый ПостроительЗапроса;
	ПЗ.ИсточникДанных			= Новый ОписаниеИсточникаДанных(ТабДок.Область());
	ПЗ.ДобавлениеПредставлений	= ТипДобавленияПредставлений.Добавлять;
	ПЗ.ЗаполнитьНастройки();
	ПЗ.Выполнить();
	ТЗ = ПЗ.Результат.Выгрузить();
	
	ЧислоСтрока = "Число";
	Если СопоставлениеПоНаименованию Тогда
		// Дополняем колонками из макета, если в ТД они отсутствовали
		Для Каждого СтрокаМакета Из Макет Цикл
			Если ТЗ.Колонки.Найти(СтрокаМакета.ИмяКолонки) = Неопределено Тогда
				ТЗ.Колонки.Добавить(СтрокаМакета.ИмяКолонки, Новый ОписаниеТипов(СтрокаМакета.ТипЗначения));
			Иначе
				// Для колонок с типом Дата, Булево и Число необходимо преобразование
				Если СтрокаМакета.ТипЗначения = "Дата" Тогда
					НовыйТип = Новый ОписаниеТипов("Дата");
				ИначеЕсли СтрокаМакета.ТипЗначения = "Булево" Тогда
					НовыйТип = Новый ОписаниеТипов("Булево");
				ИначеЕсли СтрокаМакета.ТипЗначения = ЧислоСтрока Тогда
					НовыйТип = Новый ОписаниеТипов(ЧислоСтрока);
				Иначе
					НовыйТип = Неопределено;
				КонецЕсли;
				
				Если НовыйТип <> Неопределено Тогда
					ТЗ.Колонки[СтрокаМакета.ИмяКолонки].Имя = ТЗ.Колонки[СтрокаМакета.ИмяКолонки].Имя + "Строкой";
					ТЗ.Колонки.Добавить(СтрокаМакета.ИмяКолонки, НовыйТип);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Удаляем пустые строки, которые остались от объединения строк
	ИмяКолонки1 = ТЗ.Колонки[0].Имя;
	ИмяКолонки2 = ТЗ.Колонки[1].Имя;
	ИмяКолонки3 = ТЗ.Колонки[2].Имя;
	КоличествоСтрок = ТЗ.Количество() - 1;
	Пока КоличествоСтрок >= 0 Цикл
		СтрокаТаблицы = ТЗ[КоличествоСтрок];
		Если ПустаяСтрока(СтрокаТаблицы[ИмяКолонки1])
			И ПустаяСтрока(СтрокаТаблицы[ИмяКолонки2])
			И ПустаяСтрока(СтрокаТаблицы[ИмяКолонки3]) Тогда
			ТЗ.Удалить(СтрокаТаблицы);
		КонецЕсли;
		
		КоличествоСтрок = КоличествоСтрок - 1;
	КонецЦикла;
	
	ТЗ.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов(ЧислоСтрока));
	
	Возврат ТЗ;
	
КонецФункции

Процедура ПреобразоватьТабличныйДокументПоследовательнымСопоставлением(ТабДок, Макет)
	
	ТабДок.ВставитьОбласть(ТабДок.Область("R1"),
		ТабДок.Область("R1"),
		ТипСмещенияТабличногоДокумента.ПоГоризонтали);
	
	Табдок.Область("R1").Очистить(Истина, Истина, Истина);
	
	Счетчик = 0;
	Для Каждого СтрокаТаблицы Из Макет Цикл
		Счетчик = Счетчик + 1;
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		ТабДок.Область("R1" + "C" + Строка(Счетчик)).Текст = СтрокаТаблицы.ИмяКолонки;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПреобразоватьТабличныйДокументСопоставлениемПоНаименованиюКолонок(ТабДок, Макет)
	
	Счетчик = 1;
	КолонкиКУдалению = Новый Массив;
	УдалитьСтрокиШапки = Новый Массив;
	НомерСтроки = 0;
	ШиринаТаблицы = ТабДок.ШиринаТаблицы;
	
	ОбойтиКолонкиДокументаПоНаименованиямРекурсивно(ТабДок, Макет,
		ШиринаТаблицы, НомерСтроки, Счетчик, КолонкиКУдалению, УдалитьСтрокиШапки);
	
	// Удаляем лишние строки
	Если УдалитьСтрокиШапки.Количество() Тогда
		ОбластьКУдалению = ТабДок.Область("R" + УдалитьСтрокиШапки[0] + ":R"
			+ УдалитьСтрокиШапки[УдалитьСтрокиШапки.Количество() - 1]);
		ТабДок.УдалитьОбласть(ОбластьКУдалению, ТипСмещенияТабличногоДокумента.ПоВертикали);
	КонецЕсли;
	
	// Удаляем ненужные колонки
	КоличествоКолонокКУдалению = КолонкиКУдалению.Количество() - 1;
	Пока КоличествоКолонокКУдалению >= 0 Цикл
		НомерКолонки = КолонкиКУдалению[КоличествоКолонокКУдалению];
		ОбластьКУдалению = ТабДок.Область("C" + Строка(НомерКолонки));
		ТабДок.УдалитьОбласть(ОбластьКУдалению, ТипСмещенияТабличногоДокумента.ПоГоризонтали);
		
		КоличествоКолонокКУдалению = КоличествоКолонокКУдалению - 1;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбойтиКолонкиДокументаПоНаименованиямРекурсивно(ТабДок, Макет, ШиринаТаблицы,
	НомерСтроки, НомерКолонки, КолонкиКУдалению, УдалитьСтрокиШапки, ШиринаГруппы = 0)
	
	НомерСтроки = НомерСтроки + 1;
	
	ТекстШапки = СокрЛП(ТабДок.Область("R" + НомерСтроки + "C" + Строка(НомерКолонки)).Текст);
	ТекущаяПроверкаШирины = ?(ШиринаГруппы = 0, ШиринаТаблицы, ШиринаГруппы);
	
	Пока НомерКолонки <= ТекущаяПроверкаШирины Цикл
		Если ТекстШапки = "" Тогда
			НомерКолонки = НомерКолонки + 1;
			ТекстШапки = СокрЛП(ТабДок.Область("R" + НомерСтроки + "C" + Строка(НомерКолонки)).Текст);
			Продолжить;
		КонецЕсли;
		
		ИмяКолонки = "";
		
		// Проверяем на группы колонок
		ПоискПодчиненных = Макет.НайтиСтроки(Новый Структура("Группа", ТекстШапки));
		КоличествоПодчиненных = ПоискПодчиненных.Количество();
		Если КоличествоПодчиненных Тогда
			ВременныйМакет = Макет.СкопироватьКолонки();
			Для Каждого НайденнаяСтрока Из ПоискПодчиненных Цикл
				Если ВРег(НайденнаяСтрока.ОператорУсловия) = "И"
					Или ВРег(НайденнаяСтрока.ОператорУсловия) = "ВИРТ" Тогда
					КоличествоПодчиненных = КоличествоПодчиненных - 1;
					Продолжить;
				КонецЕсли;
				
				ЗаполнитьЗначенияСвойств(ВременныйМакет.Добавить(), НайденнаяСтрока);
			КонецЦикла;
			
			НомерНовойСтроки = НомерСтроки + 1;
			УдалитьСтрокиШапки.Добавить(НомерНовойСтроки);
			
			ОбойтиКолонкиДокументаПоНаименованиямРекурсивно(ТабДок, ВременныйМакет, ШиринаТаблицы, НомерСтроки,
				НомерКолонки, КолонкиКУдалению, УдалитьСтрокиШапки, НомерКолонки + КоличествоПодчиненных - 1);
			
			// Возвращаем текст шапки на прошлую строку, если мы выходим из рекурсии
			ТекстШапки = СокрЛП(ТабДок.Область("R" + НомерСтроки + "C" + Строка(НомерКолонки)).Текст);
		Иначе
			СверитьИмяКолонокДобавитьИмяВМакет(ТабДок, Макет, ТекстШапки, НомерСтроки, НомерКолонки, КолонкиКУдалению);
		КонецЕсли;
		
	КонецЦикла;
	
	НомерСтроки = НомерСтроки - 1;
	
КонецПроцедуры

Процедура СверитьИмяКолонокДобавитьИмяВМакет(ТабДок, Макет, ТекстШапки, НомерСтроки, НомерКолонки, КолонкиКУдалению)
	
	// Сверяем наименование колонки ТД и наименование из макета
	Для Каждого СтрокаТаблицы Из Макет Цикл
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		Если ПроверитьСоответствиеИменКолонок(ТекстШапки, СтрокаТаблицы.ИмяВТабДоке, СтрокаТаблицы.ИмяКолонки) Тогда
			ИмяКолонки = СтрокаТаблицы.ИмяКолонки;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Подменяем имя для работы с построителем; если колонки нет, то готовим ее к удалению
	Если Не ПустаяСтрока(ИмяКолонки) Тогда
		ТабДок.Область("R1" + "C" + Строка(НомерКолонки)).Текст = ИмяКолонки;
	Иначе
		КолонкиКУдалению.Добавить(НомерКолонки);
	КонецЕсли;
	
	НомерКолонки = НомерКолонки + 1;
	ТекстШапки = СокрЛП(ТабДок.Область("R" + НомерСтроки + "C" + Строка(НомерКолонки)).Текст);
	
КонецПроцедуры

Функция ПроверитьСоответствиеИменКолонок(ТекстШапки, ИмяВТабДоке, ИмяКолонки)
	
	Возврат (ЗначениеЗаполнено(ИмяВТабДоке) И НРег(ТекстШапки) = НРег(ИмяВТабДоке))
		Или (Не ЗначениеЗаполнено(ИмяВТабДоке) И НРег(ТекстШапки) = НРег(ИмяКолонки));
	
КонецФункции

Процедура ПрисвоитьНомераФорматовКолонокДат(ТЗ, СтруктураИменКолонокДат)
	
	Если Не ТЗ.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ПерваяСтрокаТаблицы = ТЗ[0];
	
	Для Каждого КлючИЗначение Из СтруктураИменКолонокДат Цикл
		Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеКолонки = ПерваяСтрокаТаблицы[КлючИЗначение.Ключ + "Строкой"];
		Если ПустаяСтрока(ЗначениеКолонки) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураИменКолонокДат.Вставить(КлючИЗначение.Ключ, ПолучитьНомерФорматаДатыИзСтроки(ЗначениеКолонки));
	КонецЦикла;
	
КонецПроцедуры

// Получает номер формата даты из строки
//
// Параметры:
//  ЗначениеКолонки	 - Строка - дата строкой
// 
// Возвращаемое значение:
//  Строка - номер формата с разделителями "_". Первый разряд показывает какой разделитель используется
//  в представлении даты, второй разряд показывает положение дня, месяца и года по отношению друг к другу, третий разряд
//  показывает представление времени в дате. Если номер формата "0_0_0" - преобразование происходит из функции XMLЗначение.
//  Первый разряд принимает значения:
//   - 1 - разделитель ".";
//   - 2 - "/";
//   - 3 - "-";
//   - 4 - " ";
//  Второй разряд принимает значения:
//   - 0 - месяц, день, год
//   - 1 - год идет первым, потом месяц и день;
//   - 2 - сначала день, потом месяц и год;
//   - 3 - сначала день, месяц СТРОКОЙ и год;
//  Третий разряд принимает значения:
//   - 0 - время отсутствует;
//   - 1 - время стандартное, 24-часовое представление
//   - 2 - время в 12-ти часовом представлении (AM / PM)
// 
//  Примеры номеров форматов:
//   - 1_1_2 - "2021.12.01 8:10 PM";
//   - 2_1_0 - "2021/12/01";
//   - 1_3_1 - "01.дек.2021 20:10";
//   - 3_1_1 - "2021-12-01 20:10"
//
Функция ПолучитьНомерФорматаДатыИзСтроки(ЗначениеКолонки)
	
	ЕстьВремя = СтрНайти(ЗначениеКолонки, ":") > 0;
	ЭтоУниверсальноеВремя = Ложь;
	
	Если ЕстьВремя Тогда
		МассивРазделителей = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			ЗначениеКолонки, ":", Истина, Истина);
		Если СтрНайти(МассивРазделителей[1], "AM") > 0
			Или СтрНайти(МассивРазделителей[1], "PM") > 0 Тогда
			РазрядВремени = "2";
		Иначе
			РазрядВремени = "1";
		КонецЕсли;
		
		МассивРазделителейДатаВремя = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			МассивРазделителей[0], " ", Истина, Истина);
		КоличествоРазделителей = 2;
		Если МассивРазделителейДатаВремя.Количество() = КоличествоРазделителей Тогда
			ТолькоДата = МассивРазделителейДатаВремя[0];
		ИначеЕсли МассивРазделителейДатаВремя.Количество() = 0 Тогда
			МассивРазделителейДатаВремя = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				МассивРазделителей[0], "T", Истина, Истина);
			Если МассивРазделителейДатаВремя.Количество() = КоличествоРазделителей Тогда
				ТолькоДата = МассивРазделителейДатаВремя[0];
				ЭтоУниверсальноеВремя = Истина;
			КонецЕсли;
		Иначе
			ТолькоДата = ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя);
		КонецЕсли;
	Иначе
		ТолькоДата = ЗначениеКолонки;
		РазрядВремени = "0";
	КонецЕсли;
	
	Если Не ЭтоУниверсальноеВремя Тогда
		Если СтрНайти(ТолькоДата, ".") > 0 Тогда
			РазрядРазделителя = "1";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, ".");
		ИначеЕсли СтрНайти(ТолькоДата, "/") > 0 Тогда
			РазрядРазделителя = "2";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, "/");
		ИначеЕсли СтрНайти(ТолькоДата, "-") > 0 Тогда
			РазрядРазделителя = "3";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, "-");
		Иначе
			РазрядРазделителя = "4";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, " ");
		КонецЕсли;
	Иначе
		РазрядРазделителя = "0";
		РазрядФормата = "0";
		РазрядВремени = "0";
	КонецЕсли;
	
	Возврат РазрядРазделителя + "_" + РазрядФормата + "_" + РазрядВремени;
	
КонецФункции

Функция ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, Разделитель)
	
	МассивРазделителей = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		ЗначениеКолонки, Разделитель, Истина, Истина);
	КоличествоПервыхСимволов = 3;
	МаксКоличествоДнейВМесяце = 31;
	СокрМесяц = ТРег(Лев(МассивРазделителей[1], КоличествоПервыхСимволов));
	Если Число(МассивРазделителей[0]) > МаксКоличествоДнейВМесяце Тогда // тут год
		РазрядФормата = "1";
	ИначеЕсли пбп_ОбщегоНазначенияКлиентСервер.ПолучитьНомерМесяцаПоСтроковомуПредставлению(СокрМесяц) = 0 Тогда
		РазрядФормата = "2";
	Иначе
		РазрядФормата = "3";
	КонецЕсли;
	
	Возврат РазрядФормата;
	
КонецФункции

Функция ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя)
	
	КоличествоСмещений = 2;
	КоличествоРазделителей = МассивРазделителейДатаВремя.Количество() - КоличествоСмещений; // В последнем часы
	Для Разделитель = 0 По КоличествоРазделителей Цикл
		ТолькоДата = ТолькоДата + ?(ПустаяСтрока(ТолькоДата), "", " ") + МассивРазделителейДатаВремя[Разделитель];
	КонецЦикла;
	
	Возврат ТолькоДата;
	
КонецФункции

// Преобразовать дату из строки по строковому формату
//
// Параметры:
//  ВхЗначение	 - Строка - дата строкой
//  НомерФормата - Строка - номер формата с разделителями "_". Подробнее см. в ПолучитьНомерФорматаДатыИзСтроки
// 
// Возвращаемое значение:
//  Дата - дата, полученная из преобразования даты строкой по формату
//
Функция ПреобразоватьДатуИзСтрокиПоФормату(ВхЗначение, НомерФормата)
	
	Если Не ЗначениеЗаполнено(ВхЗначение) Тогда
		Возврат Дата(1, 1, 1, 0, 0, 0);
	КонецЕсли;
	
	ПреобразованнаяДата = Неопределено;
	Если НомерФормата = "0_0_0" Тогда
		ПреобразованнаяДата = XMLЗначение(Тип("Дата"), ВхЗначение);
	Иначе
		РазрядыФормата = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(НомерФормата, "_");
		
		СтрокаВремя = "";
		Если РазрядыФормата[2] = "0" Тогда
			СтрокаВремя = "00:00:00";
			ТолькоДата = ВхЗначение;
		Иначе
			МассивРазделителей = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				ВхЗначение, ":", Истина, Истина);
			
			МассивРазделителейДатаВремя = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				МассивРазделителей[0], " ", Истина, Истина);
			Если РазрядыФормата[0] = "4" Тогда
				ТолькоДата = ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя);
			Иначе
				ТолькоДата = МассивРазделителейДатаВремя[0];
			КонецЕсли;
			
			Если РазрядыФормата[1] = "1" Тогда
				Часы = МассивРазделителейДатаВремя[МассивРазделителейДатаВремя.Количество() - 1];
				МинутыСекунды = МассивРазделителей[1];
			Иначе
				ЧасыБезСдвигаЧисло = Число(МассивРазделителейДатаВремя[МассивРазделителейДатаВремя.Количество() - 1]);
				КоличествоСимволовДоПослеОбеда = 2;
				КоличествоЧасовСдвига = 12;
				Если Прав(МинутыСекунды, КоличествоСимволовДоПослеОбеда) = "PM" Тогда
					Часы = ЧасыБезСдвигаЧисло + КоличествоЧасовСдвига;
				Иначе
					Часы = ЧасыБезСдвигаЧисло;
				КонецЕсли;
				
				МинутыСекунды = СтрЗаменить(МинутыСекунды, " AM", "");
				МинутыСекунды = СтрЗаменить(МинутыСекунды, " PM", "");
			КонецЕсли;
			
			СтрокаВремя = Строка(Часы) + ":" + МинутыСекунды;
		КонецЕсли;
		
		Если РазрядыФормата[0] = "1" Тогда
			РазделительРазрядов = ".";
		ИначеЕсли РазрядыФормата[0] = "2" Тогда
			РазделительРазрядов = "/";
		ИначеЕсли РазрядыФормата[0] = "3" Тогда
			РазделительРазрядов = "-";
		Иначе
			РазделительРазрядов = " ";
		КонецЕсли;
		
		МассивГодМесяцДата = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			ТолькоДата, РазделительРазрядов, Истина, Истина);
		
		Если РазрядыФормата[1] = "0" Тогда
			Год = МассивГодМесяцДата[2];
			Месяц = МассивГодМесяцДата[0];
			День = МассивГодМесяцДата[1];
		ИначеЕсли РазрядыФормата[1] = "1" Тогда
			Год = МассивГодМесяцДата[0];
			Месяц = МассивГодМесяцДата[1];
			День = МассивГодМесяцДата[2];
		ИначеЕсли РазрядыФормата[1] = "2" Тогда
			Год = МассивГодМесяцДата[2];
			Месяц = МассивГодМесяцДата[1];
			День = МассивГодМесяцДата[0];
		Иначе
			Год = МассивГодМесяцДата[2];
			КоличествоПервыхСимволов = 3;
			СокрМесяц = ТРег(Лев(МассивГодМесяцДата[1], КоличествоПервыхСимволов));
			Месяц = пбп_ОбщегоНазначенияКлиентСервер.ПолучитьНомерМесяцаПоСтроковомуПредставлению(СокрМесяц);
			День = МассивГодМесяцДата[0];
		КонецЕсли;
		
		НомерЧислаБезНуля = 10;
		Если Число(Месяц) < НомерЧислаБезНуля И Лев(Месяц, 1) <> "0" Тогда
			Месяц = "0" + Месяц;
		КонецЕсли;
		
		Если Число(День) < НомерЧислаБезНуля И Лев(День, 1) <> "0" Тогда
			День = "0" + День;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(МинутыСекунды) Тогда
			МассивСекМин = пбп_ПереадресацияКлиентСервер.РазложитьСтрокуВМассивПодстрок(МинутыСекунды, ":", Истина, Истина);
			
			МинутыЧисло = Число(МассивСекМин[0]);
			СекундыЧисло = Число(МассивСекМин[1]);
			ЧасыЧисло = Часы;
		Иначе
			МинутыЧисло = 0;
			СекундыЧисло = 0;
			ЧасыЧисло = 0;
		КонецЕсли;
		
		ПреобразованнаяДата = Дата(Год, Месяц, День, ЧасыЧисло, МинутыЧисло, СекундыЧисло);
		
	КонецЕсли;
	
	Возврат ПреобразованнаяДата;
	
КонецФункции

Функция ПреобразоватьЧислоИзСтроки(ВхЗначение)
	
	СтроковоеЗначение = СокрЛП(ВхЗначение);
	СтроковоеЗначение = СтрЗаменить(ВхЗначение, ",", ".");
	СтроковоеЗначение = СтрЗаменить(ВхЗначение, Символы.НПП, "");
	Возврат пбп_ПереадресацияКлиентСервер.СтрокаВЧисло(СтроковоеЗначение);
	
КонецФункции

#КонецОбласти // СлужебныеПроцедурыИФункции